#+PROPERTY: tangle sequent0.scm
#+title: sequent0

* todo

  - binding-stack
    unify
    cover
    occur-check
    consistent-check
  - return-stack
    explain
    type-explain
  - data-stack
    interface for trunk
  - type-check
  - compute

* 記

  - 回到 stack-based 的實現方式
    以明確 cut 在實現中的出現
    要知道
    形成 trunk 是因爲 branch
    而 cut 中不會出現 branch

  - 使用完全的 threaded-code-interpreter
    包括 return-stack
    不同的 context 就是不同的 return-stack 處理函數

  - 用完全不同的方式來處理 eq 而不計較理論特性
    cut 中 data uni (uni at level-0) 而 type cover
    可以解決 eq 的對稱性問題
    也能解決 (-> (:d : A) :d P) 的問題
    這樣出現 uni 的地方就有兩處
    一爲如上
    另一爲 branch 的 antecedent 對 type 的 antecedent 的特化

  - 可以用遞歸函數來證明 trunk 之間的 eq
    因此 eq 可以用來 rewrite trunk
    因此 eq 也可以用來 rewrite data

  - trunk 可以在 compute 中出現
    需要在 stack 中加入 interface 處理 trunk
    每次遇到 trunk 都嘗試 rewrite

  - 分離處理如下四種情況
    |      | type-check | compute |
    |------+------------+---------|
    | jo   |            |         |
    | data |            |         |
    jo 不爲 call 優化而直接用 (<tag> ~)

* note

*** data

    #+begin_src scheme :tangle no
    (type data
      var                id
      cons               name {data ...}
      arrow              jojo jojo
      lambda             type body
      bind               data var
      trunk              type trunk-body {data ...} index)

    (type type
      arrow              ~
      jojo               ~)

    (type jojo           {jo ...})
    (type body           {arrow ...})

    (type trunk-body
      trunk-name         name
      trunk-var          var
      trunk-arrow-list   {arrow ...})

    (type id             (vector (name . counter) ls))
    ;; vector thus unique
    ;; ls (level binding-list) for commit
    #+end_src

*** jo

    #+begin_src scheme :tangle no
    (type jo
      var                ~
      call               name
      limited-call       name jojo
      limited-apply      jo   jojo
      arrow              ~
      lambda             ~
      ex-bind            jo   {var ...}
      im-bind            jo   {var ...})
    #+end_src

*** pre-jo

    #+begin_src scheme :tangle no
    (type pre-jo
      pre-var            name
      pre-call           name
      pre-limited-call   name     pre-jojo
      pre-limited-apply  pre-jo   pre-jojo
      pre-arrow          pre-jojo pre-jojo
      pre-lambda         pre-type pre-body
      pre-ex-bind        pre-jo   {pre-var ...}
      pre-im-bind        pre-jo   {pre-var ...})

    (type pre-type
      pre-arrow          ~
      pre-jojo           ~)

    (type pre-jojo       {pre-jo ...})
    (type pre-body       {pre-arrow ...})
    #+end_src

*** meaning

    #+begin_src scheme :tangle no
    (type meaning
      meaning-type-cons  pre-type name {name ...}
      meaning-data-cons  pre-type name name
      meaning-jojo       pre-type pre-jojo
      meaning-function   pre-type pre-body)
    #+end_src

*** stack

    #+begin_src scheme :tangle no
    (type name-stack     {(name . meaning) ...})

    (type data-stack     {data ...})

    (type binding-stack  {(id . ls) ...})
    (type ls             {(level . data) ...})

    (type return-stack   {(evaler . jojo) ...})
    (type explainer
      explain
      type-explain)
    #+end_src

* stack

  #+begin_src scheme
  (define data-stack '())
  (define return-stack '())
  (define binding-stack '())
  (define name-stack '())

  (define-macro (push stack value)
    `(set! ,stack (cons ,value ,stack)))
  #+end_src

* compile

*** help

    #+begin_src scheme
    (define (head->name head)
      (car head))

    (define (head->type head)
      (cdr (cdr head)))
    #+end_src

*** compile-jo

    #+begin_src scheme
    (define (compile-jo jo)
      (define (var? v)
        (and (symbol? v)
             (equal? ":" (substring (symbol->string v) 0 1))))
      (define (call? v)
        (and (symbol? v)
             (not (eq? ":" (substring (symbol->string v) 0 1)))))
      (define (limited-call? v)
        (and (list? v)
             (not (member '-> v))
             (not (eq? (car v) 'lambda))
             (not (member ': v))
             (symbol? (last v))
             (not (var? (last v)))))
      (define (limited-apply? v)
        (and (list? v)
             (not (member '-> v))
             (not (eq? (car v) 'lambda))
             (not (member ': v))
             (or (not (symbol? (last v)))
                 (var? (last v)))))
      (define (arrow? v)
        (and (list? v)
             (member '-> v)))
      (define (lambda? v)
        (and (list? v)
             (eq? (car v) 'lambda)))
      (define (ex-bind? v)
        (and (list? v) (pair? v)
             (not (equal? (car v) (vector 'flower-barcket/as-im-bind)))
             (member ': v)))
      (define (im-bind? v)
        (and (list? v) (pair? v)
             (equal? (car v) (vector 'flower-barcket/as-im-bind))
             (member ': v)))
      (cond [(var? jo)                (list 'pre-var jo)]
            [(call? jo)               (list 'pre-call jo)]
            [(limited-call? jo)       (compile-limited-call jo)]
            [(limited-apply? jo)      (compile-limited-apply jo)]
            [(arrow? jo)              (compile-arrow jo)]
            [(lambda? jo)             (compile-lambda jo)]
            [(ex-bind? jo)            (compile-ex-bind jo)]
            [(im-bind? jo)            (compile-im-bind (cdr jo))]))
    #+end_src

*** compile-ex-bind

    #+begin_src scheme
    (define (compile-ex-bind jo)
      (list 'pre-ex-bind
            (compile-jo (car (right-of ': jo)))
            (compile-jojo (left-of ': jo))))
    #+end_src

*** compile-im-bind

    #+begin_src scheme
    (define (compile-im-bind jo)
      (list 'pre-im-bind
            (compile-jo (car (right-of ': jo)))
            (compile-jojo (left-of ': jo))))
    #+end_src

*** compile-jojo

    #+begin_src scheme
    (define (compile-jojo jojo)
      (map compile-jo jojo))
    #+end_src

*** compile-arrow

    #+begin_src scheme
    (define (compile-arrow arrow)
      (list 'pre-arrow
            (compile-jojo (left-of '-> arrow))
            (compile-jojo (right-of '-> arrow))))
    #+end_src

*** compile-type

    #+begin_src scheme
    (define (compile-type type)
      (define (arrow? s)
        (and (eq? (length s) 1)
             (list? (car s))
             (member '-> (car s))))
      (cond [(arrow? type)
             (compile-arrow (car type))]
            [else
             (list 'pre-jojo (compile-jojo type))]))
    #+end_src

*** compile-body

    #+begin_src scheme
    (define (compile-body body)
      (map compile-arrow body))
    #+end_src

*** compile-lambda

    #+begin_src scheme
    (define (compile-lambda lambda)
      (list 'pre-lambda
            (compile-type (car (cdr lambda)))
            (compile-body (cdr (cdr lambda)))))
    #+end_src

*** compile-limited-call

    - note the
      nested (jo ... name) in (jo ... (jo ... name))
      is not limited-call but limited-apply
      becaus such limited-call shoule be written as
      (jo ... jo ... name)

    #+begin_src scheme
    (define (compile-limited-call l)
      (list 'pre-limited-call
            (last l)
            (compile-jojo (drop-last l))))
    #+end_src

*** compile-limited-apply

    #+begin_src scheme
    (define (compile-limited-apply l)
      (define (var? v)
        (and (symbol? v)
             (equal? ":" (substring (symbol->string v) 0 1))))
      (define (arrow? v)
        (and (list? v)
             (member '-> v)))
      (define (lambda? v)
        (and (list? v)
             (eq? (car v) 'lambda)))
      (define last-jo (last l))
      (define function-jojo
        (cond [(or (var? last-jo)
                   (arrow? last-jo)
                   (lambda? last-jo))
               (list (compile-jo last-jo))]
              [else
               (compile-jojo last-jo)]))
      (list 'pre-limited-apply
            function-jojo
            (compile-jojo (drop-last l))))
    #+end_src

*** flower-barcket/as-im-bind

    #+begin_src scheme
    (define (flower-barcket/as-im-bind body)
      (flower-barcket
       (lambda (dl)
         (cons (vector 'flower-barcket/as-im-bind)
               dl))
       body))
    #+end_src

*** print-define+ & print-define-

    #+begin_src scheme
    (define print-define-flag #f)
    (define (print-define+) (set! print-define-flag #t))
    (define (print-define-) (set! print-define-flag #f))
    #+end_src

*** define-jojo

    #+begin_src scheme
    (define-macro (define-jojo . body)
      `(define-jojo1 . ,(flower-barcket/as-im-bind body)))

    (define-macro (define-jojo head . tail)
      `($define-jojo (quote ,head) (quote ,tail)))

    (define ($define-jojo head tail)
      (define name (head->name head))
      (define meaning
        (list 'meaning-jojo
              (compile-type (head->type head))
              (compile-jojo tail)))
      (push name-stack
            (cons name meaning))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<define-jojo>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</define-jojo>\n")
          (display "\n"))))
    #+end_src

*** define-function

    #+begin_src scheme
    (define-macro (define-function . body)
      `(define-function1 . ,(flower-barcket/as-im-bind body)))

    (define-macro (define-function1 head . tail)
      `($define-function (quote ,head) (quote ,tail)))

    (define ($define-function head tail)
      (define name (head->name head))
      (define meaning
        (list 'meaning-function
              (compile-type (head->type head))
              (compile-body tail)))
      (push name-stack
            (cons name meaning))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<define-function>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</define-function>\n")
          (display "\n"))))
    #+end_src

*** define-type

    #+begin_src scheme
    (define-macro (define-type . body)
      `(define-type1 . ,(flower-barcket/as-im-bind body)))

    (define-macro (define-type1 head . tail)
      `($define-type (quote ,head) (quote ,tail)))

    (define ($define-type head tail)
      (define name (head->name head))
      (define data-name-list (map car tail))
      (define meaning
        (list 'meaning-type-cons
              (compile-type (head->type head))
              name
              data-name-list))
      (push name-stack
            (cons name meaning))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<define-type>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</define-type>\n")
          (display "\n")))
      (map (lambda (h)
             ($define-data h name))
        tail)
      (void))

    (define ($define-data head type-name)
      (define name (head->name head))
      (define meaning
        (list 'meaning-data-cons
              (compile-type (head->type head))
              name
              type-name))
      (push name-stack
            (cons name meaning))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<define-data>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</define-data>\n")
          (display "\n"))))
    #+end_src

* unique-copy

*** id/new

    #+begin_src scheme
    (define id/counter 0)

    (define (id/new n ls)
      (set! id/counter (+ 1 id/counter))
      (vector (cons n id/counter) ls))
    #+end_src

*** note

    - pre-jo -> jo
      var name -> unique id
      implemented by scope passing

*** unique-copy/pre-jojo

    #+begin_src scheme
    (define (unique-copy/pre-jojo pjj s)
      (: pre-jojo scope -> {jojo scope})
      (match pjj
        [{} {{} s}]
        [(pj . r)
         (match (unique-copy/pre-jo pj s)
           [{j s1}
            (match (unique-copy/pre-jojo r s1)
              [{jj s2}
               {(cons j jj) s2}])])]))
    #+end_src

*** unique-copy/pre-type

    #+begin_src scheme
    (define (unique-copy/pre-type pt s)
      (case (car pt)
        ['pre-arrow (unique-copy/pre-arrow pt s)]
        [else (unique-copy/pre-jojo pt s)]))
    #+end_src

*** unique-copy/pre-body

    #+begin_src scheme
    (define (unique-copy/pre-body pb s)
      (match pb
        [{} {{} s}]
        [(pa . r)
         (match (unique-copy/pre-arrow pa s)
           [{a s1}
            (match (unique-copy/pre-body r s1)
              [{b s2}
               {(cons a b) s2}])])]))
    #+end_src

*** unique-copy/pre-jo

***** unique-copy/pre-jo

      #+begin_src scheme
      (define (unique-copy/pre-jo pj s)
        (: pre-jo scope -> {jo scope})
        (case (car pjj)
          ['pre-var           (unique-copy/pre-var pj s)]
          ['pre-call          (unique-copy/pre-call pj s)]
          ['pre-limited-call  (unique-copy/pre-limited-call pj s)]
          ['pre-limited-apply (unique-copy/pre-limited-apply pj s)]
          ['pre-arrow         (unique-copy/pre-arrow pj s)]
          ['pre-lambda        (unique-copy/pre-lambda pj s)]
          ['pre-ex-bind       (unique-copy/pre-ex-bind pj s)]
          ['pre-im-bind       (unique-copy/pre-im-bind pj s)]))
      #+end_src

***** unique-copy/pre-var

      #+begin_src scheme
      (define (unique-copy/pre-var pv s)
        (match pv
          [{'pre-var n}
           (let ([found (assq n s)])
             (if found
               (let ([old-id (cdr found)])
                 {{'var old-id} s})
               (let ([new-id (id/new n '())])
                 {{'var new-id}
                  (cons (cons n new-id) s)})))]))
      #+end_src

***** unique-copy/pre-call

      #+begin_src scheme
      (define (unique-copy/pre-call pc s)
        (match pc
          [{'pre-call n}
           {{'call n} s}]))
      #+end_src

***** unique-copy/pre-limited-call

      #+begin_src scheme
      (define (unique-copy/pre-limited-call pc s)
        (match pc
          [{'pre-limited-call n pjj}
           (match (unique-copy/pre-jojo pjj s)
             [{jj s1}
              {{'limited-call n jj} s1}])]))
      #+end_src

***** unique-copy/pre-limited-apply

      #+begin_src scheme
      (define (unique-copy/pre-limited-apply pa s)
        (match pa
          [{'pre-limited-apply pj pjj}
           (match (unique-copy/pre-jo pj s)
             [[{j s1}]
              (match (unique-copy/pre-jojo pjj s1)
                [{jj s2}
                 {{'limited-apply j jj} s2}])])]))
      #+end_src

***** unique-copy/pre-arrow

      #+begin_src scheme
      (define (unique-copy/pre-arrow pa s)
        (match pa
          [{'pre-arrow pjj1 pjj2}
           (match (unique-copy/pre-jojo pjj1 s)
             [[{jj1 s1}]
              (match (unique-copy/pre-jojo pjj2 s1)
                [{jj2 s2}
                 {{'array jj1 jj2} s2}])])]))
      #+end_src

***** unique-copy/pre-lambda

      #+begin_src scheme
      (define (unique-copy/pre-lambda pl s)
        (match pl
          [{'pre-lambda pt pb}
           (match (unique-copy/pre-type pt s)
             [[{t s1}]
              (match (unique-copy/pre-body pb s1)
                [{b s2}
                 {{'lambda t b} s2}])])]))
      #+end_src

***** unique-copy/pre-ex-bind

      #+begin_src scheme
      (define (unique-copy/pre-ex-bind pe s)
        (match pe
          [{'pre-ex-bind pj pvl}
           (match (unique-copy/pre-jo pj s)
             [[{j s1}]
              (match (unique-copy/pre-jojo pvl s1)
                [{vl s2}
                 {{'ex-bind j vl} s2}])])]))
      #+end_src

***** unique-copy/pre-im-bind

      #+begin_src scheme
      (define (unique-copy/pre-im-bind pi s)
        (match pi
          [{'pre-im-bind pj pvl}
           (match (unique-copy/pre-jo pj s)
             [[{j s1}]
              (match (unique-copy/pre-jojo pvl s1)
                [{vl s2}
                 {{'im-bind j vl} s2}])])]))
      #+end_src

* >< binding-stack

*** occur-check

*** consistent-check

*** unify

*** cover

* >< return-stack

*** explain

*** type-explain

* >< data-stack

*** interface for trunk

* >< type-check

* >< compute

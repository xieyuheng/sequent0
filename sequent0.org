#+PROPERTY: tangle sequent0.scm
#+title: sequent0

* todo

  - add level back to var
  - cover
  - unify
  - compute
  - type-check
  - when is trunk -> redex ?

* note

*** terminology

    | element | list of elements |
    |---------+------------------|
    | jo      | jojo             |
    | data    | data-list        |
    | arrow   | body             |

*** dispatching

    | jo      | data    | double data |
    |---------+---------+-------------|
    | compose | bs/deep | cover       |
    | cut     |         | unify       |

*** data & jo

    #+begin_src scheme :tangle no
    (type data
      var                id   level
      cons               name {data ...}
      arrow              jojo jojo
      lambda             type body
      bind               data sub-data
      trunk              type (vector trunky) index)

    (type trunky
      todo               body {data ...}
      done               {data ...})

    (type type
      arrow              ~
      jojo               ~)

    (type jojo           {jo ...})
    (type body           {arrow ...})

    (type id             (vector (name . counter) ls))
    ;; vector thus unique
    ;; ls (level binding-list) in id for commit

    (type jo
      var                ~
      call               name
      arrow              ~
      lambda             ~
      apply
      ex-bind            jo   jojo
      im-bind            jo   jojo)
    #+end_src

*** pre-jo & meaning

    #+begin_src scheme :tangle no
    (type pre-jo
      pre-var            name
      pre-call           name
      pre-arrow          pre-jojo pre-jojo
      pre-lambda         pre-type pre-body
      pre-ex-bind        pre-jo   pre-jojo
      pre-im-bind        pre-jo   pre-jojo)

    (type pre-type
      pre-arrow          ~
      pre-jojo           ~)

    (type pre-jojo       {pre-jo ...})
    (type pre-body       {pre-arrow ...})

    (type meaning
      meaning-type-cons  pre-type name {name ...}
      meaning-data-cons  pre-type name name
      meaning-jojo       pre-type pre-jojo
      meaning-function   pre-type pre-body)
    #+end_src

*** stack

    #+begin_src scheme :tangle no
    (type ns {(name . meaning) ...})

    (type ds {data ...})

    (type bs {(id . ls) ...})
    (type ls {(level . data) ...})

    (type rs {{counter explainer ender jojo} ...})
    (type gs {{counter explainer ender {data-list data-list}} ...})
    #+end_src

* stack

  #+begin_src scheme
  (define ns '())
  (define ds '())
  (define bs '())
  (define rs '())
  (define gs '())

  (define-macro (push s v) `(set! ,s (cons ,v ,s)))
  (define-macro (put s l)
    `(set! ,s (append ,l ,s)))

  (define-macro (tos s)    (car s))
  (define-macro (pop s)
    (let ([v (gensym "pop/v")])
      `(let ([,v (car ,s)])
         (set! ,s (cdr ,s))
         v)))
  (define-macro (fetch s n)
    (let ([v (gensym "fetch/v")])
      `(let ([,v (take ,s n)])
         (set! ,s (drop ,s n))
         v)))
  #+end_src

* compile

*** help

    #+begin_src scheme
    (define (head->name head)
      (car head))

    (define (head->type head)
      (cdr (cdr head)))
    #+end_src

*** compile-jo

    #+begin_src scheme
    (define (compile-jo jo)
      (define (var? v)
        (and (symbol? v)
             (equal? ":" (substring (symbol->string v) 0 1))))
      (define (call? v)
        (and (symbol? v)
             (not (eq? ":" (substring (symbol->string v) 0 1)))))
      (define (apply? v)
        (eq? v 'apply))
      (define (arrow? v)
        (and (list? v)
             (member '-> v)))
      (define (lambda? v)
        (and (list? v)
             (eq? (car v) 'lambda)))
      (define (ex-bind? v)
        (and (list? v) (pair? v)
             (not (equal? (car v) (vector 'flower-barcket/as-im-bind)))
             (member ': v)))
      (define (im-bind? v)
        (and (list? v) (pair? v)
             (equal? (car v) (vector 'flower-barcket/as-im-bind))
             (member ': v)))
      (cond [(var? jo)                (list 'pre-var jo)]
            [(call? jo)               (list 'pre-call jo)]
            [(apply? jo)              (list 'pre-apply)]
            [(arrow? jo)              (compile-arrow jo)]
            [(lambda? jo)             (compile-lambda jo)]
            [(ex-bind? jo)            (compile-ex-bind jo)]
            [(im-bind? jo)            (compile-im-bind (cdr jo))]))
    #+end_src

*** compile-ex-bind

    #+begin_src scheme
    (define (compile-ex-bind jo)
      (list 'pre-ex-bind
            (compile-jo (car (right-of ': jo)))
            (compile-jojo (left-of ': jo))))
    #+end_src

*** compile-im-bind

    #+begin_src scheme
    (define (compile-im-bind jo)
      (list 'pre-im-bind
            (compile-jo (car (right-of ': jo)))
            (compile-jojo (left-of ': jo))))
    #+end_src

*** compile-jojo

    #+begin_src scheme
    (define (compile-jojo jojo)
      (map compile-jo jojo))
    #+end_src

*** compile-arrow

    #+begin_src scheme
    (define (compile-arrow arrow)
      (list 'pre-arrow
            (compile-jojo (left-of '-> arrow))
            (compile-jojo (right-of '-> arrow))))
    #+end_src

*** compile-type

    #+begin_src scheme
    (define (compile-type type)
      (define (arrow? s)
        (and (eq? (length s) 1)
             (list? (car s))
             (member '-> (car s))))
      (cond [(arrow? type)
             (compile-arrow (car type))]
            [else
             (list 'pre-jojo (compile-jojo type))]))
    #+end_src

*** compile-body

    #+begin_src scheme
    (define (compile-body body)
      (map compile-arrow body))
    #+end_src

*** compile-lambda

    #+begin_src scheme
    (define (compile-lambda lambda)
      (list 'pre-lambda
            (compile-type (car (cdr lambda)))
            (compile-body (cdr (cdr lambda)))))
    #+end_src

*** flower-barcket/as-im-bind

    #+begin_src scheme
    (define (flower-barcket/as-im-bind body)
      (flower-barcket
       (lambda (dl)
         (cons (vector 'flower-barcket/as-im-bind)
               dl))
       body))
    #+end_src

*** print-define+ & print-define-

    #+begin_src scheme
    (define print-define-flag #f)
    (define (print-define+) (set! print-define-flag #t))
    (define (print-define-) (set! print-define-flag #f))
    #+end_src

*** define-jojo

    #+begin_src scheme
    (define-macro (define-jojo . body)
      `(define-jojo1 . ,(flower-barcket/as-im-bind body)))

    (define-macro (define-jojo head . tail)
      `($define-jojo (quote ,head) (quote ,tail)))

    (define ($define-jojo head tail)
      (define name (head->name head))
      (define meaning
        (list 'meaning-jojo
              (compile-type (head->type head))
              (compile-jojo tail)))
      (push ns (cons name meaning))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<define-jojo>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</define-jojo>\n")
          (display "\n"))))
    #+end_src

*** define-function

    #+begin_src scheme
    (define-macro (define-function . body)
      `(define-function1 . ,(flower-barcket/as-im-bind body)))

    (define-macro (define-function1 head . tail)
      `($define-function (quote ,head) (quote ,tail)))

    (define ($define-function head tail)
      (define name (head->name head))
      (define meaning
        (list 'meaning-function
              (compile-type (head->type head))
              (compile-body tail)))
      (push ns (cons name meaning))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<define-function>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</define-function>\n")
          (display "\n"))))
    #+end_src

*** define-type

    #+begin_src scheme
    (define-macro (define-type . body)
      `(define-type1 . ,(flower-barcket/as-im-bind body)))

    (define-macro (define-type1 head . tail)
      `($define-type (quote ,head) (quote ,tail)))

    (define ($define-type head tail)
      (define name (head->name head))
      (define data-name-list (map car tail))
      (define meaning
        (list 'meaning-type-cons
              (compile-type (head->type head))
              name
              data-name-list))
      (push ns (cons name meaning))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<define-type>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</define-type>\n")
          (display "\n")))
      (map (lambda (h)
             ($define-data h name))
        tail)
      (void))

    (define ($define-data head type-name)
      (define name (head->name head))
      (define meaning
        (list 'meaning-data-cons
              (compile-type (head->type head))
              name
              type-name))
      (push ns (cons name meaning))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<define-data>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</define-data>\n")
          (display "\n"))))
    #+end_src

* unique-copy

*** id/new

    #+begin_src scheme
    (define id/counter 0)

    (define (id/new n ls)
      (set! id/counter (+ 1 id/counter))
      (vector (cons n id/counter) ls))
    #+end_src

*** note

    - pre-jo -> jo
      var name -> unique id
      implemented by scope passing

*** unique-copy/pre-jojo

    #+begin_src scheme
    (define (unique-copy/pre-jojo pjj s)
      (: pre-jojo scope -> {jojo scope})
      (match pjj
        [{} {{} s}]
        [(pj . r)
         (match (unique-copy/pre-jo pj s)
           [{j s1}
            (match (unique-copy/pre-jojo r s1)
              [{jj s2}
               {(cons j jj) s2}])])]))
    #+end_src

*** unique-copy/pre-type

    #+begin_src scheme
    (define (unique-copy/pre-type pt s)
      (case (car pt)
        ['pre-arrow (unique-copy/pre-arrow pt s)]
        [else (unique-copy/pre-jojo pt s)]))
    #+end_src

*** unique-copy/pre-body

    #+begin_src scheme
    (define (unique-copy/pre-body pb s)
      (match pb
        [{} {{} s}]
        [(pa . r)
         (match (unique-copy/pre-arrow pa s)
           [{a s1}
            (match (unique-copy/pre-body r s1)
              [{b s2}
               {(cons a b) s2}])])]))
    #+end_src

*** unique-copy/pre-jo

***** unique-copy/pre-jo

      #+begin_src scheme
      (define (unique-copy/pre-jo pj s)
        (: pre-jo scope -> {jo scope})
        (case (car pjj)
          ['pre-var           (unique-copy/pre-var pj s)]
          ['pre-call          (unique-copy/pre-call pj s)]
          ['pre-apply         (unique-copy/pre-apply pj s)]
          ['pre-arrow         (unique-copy/pre-arrow pj s)]
          ['pre-lambda        (unique-copy/pre-lambda pj s)]
          ['pre-ex-bind       (unique-copy/pre-ex-bind pj s)]
          ['pre-im-bind       (unique-copy/pre-im-bind pj s)]))
      #+end_src

***** unique-copy/pre-var

      #+begin_src scheme
      (define (unique-copy/pre-var pv s)
        (match pv
          [{'pre-var n}
           (let ([found (assq n s)])
             (if found
               (let ([old-id (cdr found)])
                 {{'var old-id} s})
               (let ([new-id (id/new n '())])
                 {{'var new-id}
                  (cons (cons n new-id) s)})))]))
      #+end_src

***** unique-copy/pre-call

      #+begin_src scheme
      (define (unique-copy/pre-call pc s)
        (match pc
          [{'pre-call n}
           {{'call n} s}]))
      #+end_src

***** unique-copy/pre-apply

      #+begin_src scheme
      (define (unique-copy/pre-apply pa s)
        (match pa
          [{'pre-apply} {{'apply} s}]))
      #+end_src

***** unique-copy/pre-arrow

      #+begin_src scheme
      (define (unique-copy/pre-arrow pa s)
        (match pa
          [{'pre-arrow pjj1 pjj2}
           (match (unique-copy/pre-jojo pjj1 s)
             [[{jj1 s1}]
              (match (unique-copy/pre-jojo pjj2 s1)
                [{jj2 s2}
                 {{'array jj1 jj2} s2}])])]))
      #+end_src

***** unique-copy/pre-lambda

      #+begin_src scheme
      (define (unique-copy/pre-lambda pl s)
        (match pl
          [{'pre-lambda pt pb}
           (match (unique-copy/pre-type pt s)
             [[{t s1}]
              (match (unique-copy/pre-body pb s1)
                [{b s2}
                 {{'lambda t b} s2}])])]))
      #+end_src

***** unique-copy/pre-ex-bind

      #+begin_src scheme
      (define (unique-copy/pre-ex-bind pe s)
        (match pe
          [{'pre-ex-bind pj pjj}
           (match (unique-copy/pre-jo pj s)
             [[{j s1}]
              (match (unique-copy/pre-jojo pjj s1)
                [{jj s2}
                 {{'ex-bind j jj} s2}])])]))
      #+end_src

***** unique-copy/pre-im-bind

      #+begin_src scheme
      (define (unique-copy/pre-im-bind pi s)
        (match pi
          [{'pre-im-bind pj pjj}
           (match (unique-copy/pre-jo pj s)
             [[{j s1}]
              (match (unique-copy/pre-jojo pjj s1)
                [{jj s2}
                 {{'im-bind j jj} s2}])])]))
      #+end_src

* bs

*** bs/commit & id/commit

    #+begin_src scheme
    (define (bs/commit)
      (define (recur bs0)
        (cond [(equal? '(commit-point) (car bs0))
               (set! bs (cdr bs0))]
              [else
               (let ([id (car (car bs0))]
                     [ls (cdr (car bs0))])
                 (id/commit id ls)
                 (recur (cdr bs0)))]))
      (recur bs))

    (define (id/commit id ls)
      (: id ls -> id [with effect on id])
      (let ()
        (vector-set! id 1 (append ls (vector-ref id 1)))
        id))
    #+end_src

*** bs/extend-level-0 & bs/extend-level-1

    #+begin_src scheme
    (define (bs/extend-level-0 v d)
      (: var data -> !)
      (match v
        [{'var id}
         (let ([level 0]
               [found/ls (assq id bs)])
           (if found/ls
             (set! bs (substitute `(,id . ((,level . ,d) . ,(cdr found/ls)))
                                  (lambda (pair) (eq? (car pair) id))
                                  bs))
             (push bs `(,id . ((,level . ,d))))))]))

    (define (bs/extend-level-1 v d)
      (: var data -> !)
      (match v
        [{'var id}
         (let ([level 1]
               [found/ls (assq id bs)])
           (if found/ls
             (set! bs (substitute `(,id . ((,level . ,d) . ,(cdr found/ls)))
                                  (lambda (pair) (eq? (car pair) id))
                                  bs))
             (push bs `(,id . ((,level . ,d))))))]))
    #+end_src

*** var/fresh?

    #+begin_src scheme
    (define (var/fresh? v)
      (: var -> bool)
      (equal? (bs/walk v)
              v))
    #+end_src

*** bs/find

    #+begin_src scheme
    (define (id->ls id)
      (vector-ref id 1))

    (define (bs/find v)
      (: var -> (or data #f))
      (match v
        [{'var id}
         (let* ([level 0]
                [found/commit (assq level (id->ls id))])
           (if found/commit
             (cdr found/commit)
             (let* ([found/ls (assq id bs)]
                    [found/bind
                     (if found/ls
                       (assq level (cdr found/ls))
                       #f)])
               (if found/bind
                 (cdr found/bind)
                 #f))))]))
    #+end_src

*** bs/walk

    #+begin_src scheme
    (define (bs/walk d)
      (: data -> data)
      (match d
        [{'var id}
         (let ([found (bs/find d)])
           (if found
             (bs/walk found)
             d))]
        [{__ e} d]))
    #+end_src

*** bs/deep

    #+begin_src scheme
    (define (bs/deep d)
      (: data -> data)
      (let ([d (bs/walk d)])
        (match d
          ;; a var is fresh after bs/walk
          [{'cons n dl}             {'cons n (bs/deep-list dl)}]
          [{'bind d sd}             {'bind (bs/deep d) (bs/deep sd)}]
          [{'trunk t k i}           {'trunk t (bs/deep-trunky k) i}]
          [__                    d])))

    (define (bs/deep-list dl)
      (map (lambda (x) (bs/deep x)) dl))

    (define (bs/deep-trunky k)
      (vector-set!
        k 0
        (match (vector-ref k 0)
          [{'todo b dl} {'todo b (bs/deep-list dl)}]
          [{'done dl}   {'done (bs/deep-list dl)}])))
    #+end_src

*** bs/find-level-1

    #+begin_src scheme
    (define (bs/find-level-1 v)
      (: var -> (or data #f))
      (match v
        [{'var id}
         (let* ([level 1]
                [found/commit (assq level (id->ls id))])
           (if found/commit
             (cdr found/commit)
             (let* ([found/ls (assq id bs)]
                    [found/bind
                     (if found/ls
                       (assq level (cdr found/ls))
                       #f)])
               (if found/bind
                 (cdr found/bind)
                 #f))))]))
    #+end_src

* gs

*** note goal-stack

    - binding-stack is to record solution of equations in goal-stack

*** gs/exit

    #+begin_src scheme
    (define (gs/exit) (void))
    #+end_src

*** gs/next

    #+begin_src scheme
    (define (gs/next)
      (match (tos gs)
        [{c ex end {dl1 dl2}}
         (ex)]))
    #+end_src

*** >< occur-check

*** >< consistent-check

* cover

*** note

    - cover is the poset structure of term-lattice (subsumption-lattice)

*** cover

    #+begin_src scheme
    (define (cover)
      (: -> bool)
      (match (pop gs)
        [{c ex end {dl1 dl2}}
         (cond [(>= c (length dl1))
                (end)
                #t]
               [else
                (let ([d1 (list-ref dl1 c)]
                      [d2 (list-ref dl2 c)])
                  (push {(+ 1 c) ex end {dl1 dl2}})
                  (if (cover/data/data d1 d2)
                    (gs/next)
                    #f))])]))
    #+end_src

*** ><><>< cover/data/data

    #+begin_src scheme
    (define (cover/data/data d1 d2)
      (: data data -> bool)
      ;; var -walk-> fresh-var
      (let ([d1 (bs/walk d1)]
            [d2 (bs/walk d2)])
        (match {d1 d2}
          ;; level-0 unify
          [{'bind d v}])))

    ;; (let ([p (bs/walk bs p)]
    ;;       [d (bs/walk bs d)])
    ;;   (match {p d}
    ;;     [{{'bind {__ p0}} __} (cover/data p0 d e)]
    ;;     [{__ {'bind {__ d0}}} (cover/data p d0 e)]
    ;;     [{{'var v1} {'var v2}}
    ;;      (if (var/eq? v1 v2)
    ;;        {'success e}
    ;;        (cover/var/data v1 d e))]
    ;;     [{{'var v} __} (cover/var/data v d e)]
    ;;     [{__ {'var v}}
    ;;      ;; here is the only different between unify/data
    ;;      {'fail {`(cover/data
    ;;                fail because non-var can never cover var
    ;;                (pattern: ,p)
    ;;                (data: ,d))}}]
    ;;     [{{'trunk t1} {'trunk t2}} (cover/trunk t1 t2 e)]
    ;;     [{{'trunk t} __} (cover/trunk/data t d e)]
    ;;     [{__ {'trunk t}} (cover/trunk/data t p e)]

    ;;     [{{'cons c1} {'cons c2}} (cover/cons c1 c2 e)]
    ;;     [{{'arrow a1} {'arrow a2}} (cover/arrow a1 a2 e)]
    ;;     [{{'lambda l1} {'lambda l2}} (cover/lambda l1 l2 e)]
    ;;     [{__ __}
    ;;      {'fail {`(cover/data
    ;;                fail to unify
    ;;                (pattern: ,p) (data: ,d))}}]))
    #+end_src

*** ><><>< cover/data-list/data-list

    #+begin_src scheme
    (define (cover/data-list/data-list dl1 dl2)
      (cond for-each cover/data/data jj))
    #+end_src

* >< unify

*** note

    - this is the meet (greatest lower bound) operation of term-lattice

    - first order syntactic unification

    - for unify/trunk
      first syntactic unification is tried
      if it fail
      semantic unification is used

    - except for unify/trunk/data
      semantic unification (unification modulo theory) is tried
      (try trunk -> redex)
      (computation can occur in type-check)

    - no substitutional equality
      (can use proved '=' to get explicit substitutional equality)

*** ><><>< unify

    #+begin_src scheme

    #+end_src

*** ><

    #+begin_src scheme

    #+end_src

* rs

*** rs/exit

    #+begin_src scheme
    (define (rs/exit) (void))
    #+end_src

*** rs/next

    #+begin_src scheme
    (define (rs/next)
      (match (tos rs)
        [{c ex end jj}
         (ex)]))
    #+end_src

* compose

*** compose

    #+begin_src scheme
    (define (compose)
      (match (pop rs)
        [{c ex end jj}
         (cond [(>= c (length jj))
                (end)]
               [else
                (let ([j (list-ref jj c)])
                  (push {(+ 1 c) ex end jj})
                  (compose/jo (car j))
                  (rs/next))])]))
    #+end_src

*** compose/jo

    #+begin_src scheme
    (define (compose/jo j)
      (case (car j)
        ['var           (compose/var j)]
        ['call          (compose/call j)]
        ['apply         (compose/apply j)]
        ['ex-bind       (compose/ex-bind j)]
        ['im-bind       (compose/im-bind j)]
        [__             (push ds j)]))
    #+end_src

*** compose/jojo

    - ><><><
      maybe do not need this

    #+begin_src scheme
    (define (compose/jojo jj) (for-each compose/jo jj))
    #+end_src

*** ><><>< compose/var

    - extend bs whenever meet a new var
      this helps commit

    #+begin_src scheme
    (define (compose/var j)
      (let ([d (bs/deep j)])
        (push ds d)
        ;; (match d
        ;;   [{'trunk t k i}
        ;;    ;; try trunk -> redex
        ;;    (push ds ><><><)]
        ;;   [__
        ;;    (push ds d)])
        ))
    #+end_src

*** type/input-number & type/output-number

    - it is assumed that jojo as type do not eat data-stack

    #+begin_src scheme
    (define (type/input-number t)
      (match t
        [{'arrow ajj sjj}
         (let* ([dp ds]
                [dl (let ()
                      (compose/jojo ajj)
                      (ds/gather-right dp))])
           (length dl))]
        [jj
         0]))

    (define (type/output-number t)
      (match t
        [{'arrow ajj sjj}
         (let* ([dp ds]
                [dl (let ()
                      (compose/jojo sjj)
                      (ds/gather-right dp))])
           (length dl))]
        [jj
         (let* ([dp ds]
                [dl (let ()
                      (compose/jojo jj)
                      (ds/gather-right dp))])
           (length dl))]))
    #+end_src

*** note compose/call

    - [for the first covering arrow]
      #+begin_src scheme :tangle no
      <data-on-the-stack>
      <point>
      (push rs {compose exit <antecedent>})
      <ds/gather>
      (push gs {cover commit <gathered>})
      succ -> commit (<loop>)
      fail -> undo
      (push rs {compose exit <succedent>})
      all fail -> form trunk
      #+end_src

*** compose/call

    #+begin_src scheme
    (define (compose/call j)
      (match j
        [{'call n}
         (let ([found (assq n ns)])
           (if (not found)
             (orz 'compose/call ("unknow name : ~a~%" n))
             (match (cdr found)
               [{'meaning-type-cons pt n nl}
                (let ([len (type/input-number (unique-copy/pre-type pt '()))])
                  (push ds {'cons n (fetch ds len)}))]
               [{'meaning-data-cons pt n n0}
                (let ([len (type/input-number (unique-copy/pre-type pt '()))])
                  (push ds {'cons n (fetch ds len)}))]
               [{'meaning-jojo pt pjj}
                (push rs {0 compose rs/next (unique-copy/pre-jojo pjj '())})]
               [{'meaning-function pt pb}
                (compose/function (unique-copy/pre-type pt '())
                                  (unique-copy/pre-body pb '()))])))]))

    (define (compose/function t b)
      ;; note that
      ;;   when create-trunk-list
      ;;   it needs to know the type to get input-number & output-number
      (let ([sjj (compose/try-body b)])
        (if sjj
          (push rs {0 compose rs/next sjj})
          (let ([dl (fetch ds (type/input-number t))])
            (put ds (create-trunk-list t b dl))))))

    (define (compose/try-body b)
      (: body -> (or #f sjj))
      ;; return #f on fail with undo
      (match b
        [{} #f]
        [({'arrow ajj sjj} . r)
         (let ([ds0 ds]
               [gs0 gs]
               [bs0 bs])
           (push rs {0 compose rs/exit ajj})
           (rs/next)
           (push bs '(commit-point))
           (push gs {0 cover bs/commit (ds/gather ds0)})
           (if (gs/next)
             sjj
             (begin
               (set! ds ds0)
               (set! gs gs0)
               (set! bs bs0)
               (compose/try-body r))))]))

    (define (create-trunk-list t b dl)
      (let ([k (vector {'todo b dl})])
        (reverse
         (map (lambda (i) {'trunk t k i})
           (genlist
            (type/output-number
             (unique-copy/pre-type pt)))))))
    #+end_src

*** gather-jojo

    #+begin_src scheme
    (define (gather-jojo jj)
      (let ([dp ds])
        (compose/jojo jj)
        (ds/gather-right dp)))
    #+end_src

*** compose/apply

    #+begin_src scheme
    (define (compose/apply j)
      (match (bs/walk (pop ds))
        [{'lambda t b}
         (compose/function t b)]
        [__ (orz 'compose/apply
              ("can not handle jo : ~a~%" j))]))
    #+end_src

*** compose/ex-bind

    - here use {'ex-bind j vl}
      instead of {'ex-bind j jj}
      because {'bind data non-var} can only be generated by cut

    #+begin_src scheme
    (define (compose/ex-bind j)
      (match j
        [{'ex-bind j vl}
         (let* ([dp ds]
                [dl (let ()
                      (compose/jo j)
                      (ds/gather-right dp))]
                [d (car dl)])
           (if (not (eq? (length dl) 1))
             (orz 'compose/ex-bind
               ("jo should return one data~%")
               ("but this jo does not : ~a~%" j))
             (for-each (lambda (v)
                         (bs/extend-level-1 v d)
                         (push ds {'bind d v}))
                       vl)))]))
    #+end_src

*** compose/im-bind

    #+begin_src scheme
    (define (compose/im-bind j)
      (match j
        [{'im-bind j vl}
         (let* ([dp ds]
                [dl (let ()
                      (compose/jo j)
                      (ds/gather-right dp))]
                [d (car dl)])
           (if (not (eq? (length dl) 1))
             (orz 'compose/im-bind
               ("jo should return one data~%")
               ("but this jo does not : ~a~%" j))
             (for-each (lambda (v)
                         (bs/extend-level-1 v d))
                       vl)))]))
    #+end_src

* cut

*** cut

    #+begin_src scheme
    (define (cut)
      (match (pop rs)
        [{c ex end jj}
         (cond [(>= c (length jj))
                (end)]
               [else
                (let ([j (list-ref jj c)])
                  (push {(+ 1 c) ex end jj})
                  (cut/jo (car j))
                  (rs/next))])]))
    #+end_src

*** cut/jo

    #+begin_src scheme
    (define (cut/jo j)
      (case (car j)
        ['var           (cut/var j)]
        ['call          (cut/call j)]
        ['apply         (cut/apply j)]
        ['arrow         (cut/arrow j)]
        ['lambda        (cut/lambda j)]
        ['ex-bind       (cut/ex-bind j)]
        ['im-bind       (cut/im-bind j)]))
    #+end_src

*** ><><>< cut/var

    #+begin_src scheme
    ;; - extend bs whenever meet a new var
    ;;   this helps commit

    (define (cut/var j)
      (let ([d (bs/deep j)])
        (let ([found-d (bs/find-level-1 j)])
          (if found-d
            (push ds found-d)
            (match j
              [{'var id}
               ;; seems need level in var for this cut
               ])))))
    #+end_src

*** cut/call

    #+begin_src scheme
    (define (cut/call j)
      (match j
        [{'call n}
         (let ([found (assq n ns)])
           (if (not found)
             (orz 'cut/call ("unknow name : ~a~%" n))
             (match (cdr found)
               [{'meaning-type-cons pt n nl}
                (cut/type (unique-copy/pre-type pt))]
               [{'meaning-data-cons pt n n0}
                (cut/type (unique-copy/pre-type pt))]
               [{'meaning-jojo pt pjj}
                (cut/type (unique-copy/pre-type pt))]
               [{'meaning-function pt pb}
                (cut/type (unique-copy/pre-type pt))])))]))

    (define (cut/type t)
      (match t
        [{'arrow ajj sjj}
         (cut/try-arrow t)]
        [jj
         (compose/jojo jj)]))

    (define (cut/try-arrow a)
      (: arrow -> !)
      (match a
        [{'arrow ajj sjj}
         (let ([ds0 ds])
           (push rs {0 compose rs/exit ajj})
           (rs/next)
           (push bs '(commit-point))
           (push gs {0 cover bs/commit (ds/gather ds0)})
           (if (gs/next)
             (compose/jojo sjj)
             (orz 'cut/type
               ("fail on cover~%"))))]))
    #+end_src

*** cut/apply

    #+begin_src scheme
    (define (cut/apply j)
      (match (bs/walk (pop ds))
        [{'arrow ajj sjj}
         (cut/type {'arrow ajj sjj})]
        [__ (orz 'cut/apply
              ("can not handle jo : ~a~%" j))]))
    #+end_src

*** cut/arrow

    #+begin_src scheme
    (define (cut/arrow j)
      (orz 'cut/arrow
        ("can not handle arrow as jo that is not in type~%")
        ("jo : ~a~%" j)))
    #+end_src

*** cut/lambda

    - lambda -> arrow

    #+begin_src scheme
    (define (cut/lambda j)
      (match j
        [{'lambda {'arrow ajj sjj} b}
         (push ds {'arrow ajj sjj})]
        [__
         (orz 'cut/lambda
           ("can not handle jo : ~a~%" j)
           ("for it is meaning less to write a lambda without local-vars~%"))]))
    #+end_src

*** cut/ex-bind

    #+begin_src scheme
    (define (cut/ex-bind j)
      (orz 'cut/ex-bind
        ("can not handle ex-bind as jo that is not in type~%")
        ("jo : ~a~%" j)))
    #+end_src

*** cut/im-bind

    #+begin_src scheme
    (define (cut/im-bind j)
      (orz 'cut/im-bind
        ("can not handle im-bind as jo that is not in type~%")
        ("jo : ~a~%" j)))
    #+end_src

* ds

*** ds/gather

    #+begin_src scheme
    (define (ds/gather dp)
      (: ds-pointer -> {dl1 dl2})
      (let* ([dl1 (list-sub ds dp)]
             [dl2 (fetch ds (length dl1))])
        (set! ds (drop (+ (length dl1) (length dl1))))
        (list dl1 dl2)))
    #+end_src

*** ds/gather-right

    #+begin_src scheme
    (define (ds/gather-right dp)
      (: ds-pointer -> dl)
      (let ([dl (list-sub ds dp)])
        (set! ds (drop (length dl)))
        dl))
    #+end_src

* ><><>< compute

* ><><>< type-check

*** note

    - jojo
      #+begin_src scheme :tangle no
      (push rs {cut jojo})
      <undo-when-success>
      #+end_src

    - body [for all arrow]
      #+begin_src scheme :tangle no
      (push rs {compose <type-antecedent>})
      <point>
      (push rs {compose <antecedent>})
      <ds/gather>
      (push gs {bind-unify <gathered>})

      <undo>
      (push rs {cut <antecedent>})
      <ds/gather>
      (push gs {unify <gathered>})

      (push rs {compose <type-succedent>})
      <point>
      (push rs {cut <succedent>})
      <ds/gather>
      (push gs {cover <gathered>})
      <undo-when-success>
      #+end_src

*** type-check

    #+begin_src scheme
    (define (type-check ))
    #+end_src

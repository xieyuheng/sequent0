#+PROPERTY: tangle sequent0.scm
#+title: sequent0

* todo

  - [problem] the code for rs & gs are highly duped

  - [for the steper] [maybe]
    not every call to next should be traced by the steper
    must be able to config the steper >_<
    - detailed steps for debug
      general steps for teaching or demo
    - the caller of next should give its name for debug
      thus the steper must be configed by name

  - review the commit problem
    not only in compose/try-body
    but more

  - unify should check the length of dl+ dl-

  - all that form trunk should up-unify its type to data
    apply included

  - fix d2t

  - need much more tests to show that type-check is 'safe'
    program that should not be checked
    must not be checked

  - should not allow redefine

  - recur-check

  - cover-check

* note

*** note

    - cut is hiding in call-by-need term-rewriting

    - type-infer is needed to handle d2t for arrow
      and we need a new data for this
      thus maybe we do not literal arrow in this version

    - uni-bind might be generated by up-unify

    - lambda & arrow found from top-level name
      are uni-lambda & uni-arrow indeed
      they just have empty frc [free-var-record]

*** note about frc

    - when return arrow & lambda
      arrow->uni-arrow generate new frc

    - when generate vrc by (nl->vrc nl)
      also use fnl

*** terminology

    | element | list of elements |
    |---------+------------------|
    | jo      | jojo             |
    | data    | data-list        |
    | arrow   | body             |

*** dispatching

    | jo      | data    | double data |
    |---------+---------+-------------|
    | compose | bs/deep | cover       |
    |         | d2t     | unify       |

*** syntax

    #+begin_src scheme
    (: syntax
       var                :name
       fvar               ::name
       bind               %:name
       call               name
       arrow              (-> [syntax ...] [syntax ...])
       lambda             (lambda arrow arrow ...)
       apply              @)
    #+end_src

*** jo

    #+begin_src scheme
    (: jo
       var                name
       fvar               name
       bind               name
       call               name
       arrow              {var-name ...} {fvar-name ...} {jo ...} {jo ...}
       lambda             arrow {arrow ...}
       apply)
    #+end_src

*** data

    #+begin_src scheme
    (: data
       uni-var            id level
       uni-bind           uni-var data
       cons               name {data ...}
       uni-arrow          {var-name ...} {(fvar-name . uni-var) ...} {jo ...} {jo ...}
       uni-lambda         uni-arrow {uni-arrow ...}
       trunk              adl sdl (vector trunky) index)

    (: id                 (vector (name . counter) ls))
    (: ls                 {(level . data) ...})
    ;; vector thus unique
    ;; ls (level binding-list) in id for commit

    (: trunky
       todo               {uni-arrow ...} {data ...}
       kvar               kv {data ...}
       done               {data ...})

    (: kv
       uni-var ~
       uni-lambda ~)
    #+end_src

* stack

*** debug0

    #+begin_src scheme
    (define-syntax debug0
      (syntax-rules ()
        [(debug0 who c ...)
         (let ()
           (print-ds)
           (print-rs)
           (print-gs)
           (print-bs)
           (error who (cating ("~%") c ...)))]))
    #+end_src

*** stack

    #+begin_src scheme
    (define-macro (push s v) `(set! ,s (cons ,v ,s)))

    (define-macro (push-list s l)
      `(set! ,s (append ,l ,s)))


    (define-macro (pop s)
      (let ([v (gensym "pop/v")])
        `(if (null? ,s)
           (debug0 'pop
             ("stack is empty : ~a~%" (quote ,s)))
           (let ([,v (car ,s)])
             (set! ,s (cdr ,s))
             ,v))))

    (define-macro (pop-list s n)
      (let ([v (gensym "fetch/v")])
        `(if (< (length ,s) ,n)
           (debug0 'pop-list
             ("stack is not long enough : ~a~%" (quote ,s))
             ("stack length : ~a~%" (length ,s))
             ("need length : ~a~%" ,n))
           (let ([,v (take ,s ,n)])
             (set! ,s (drop ,s ,n))
             ,v))))


    (define-macro (tos s)
      `(if (null? ,s)
         (debug0 'tos
           ("stack is empty : ~a~%" (quote ,s)))
         (car ,s)))

    (define-macro (tos-list s n)
      `(if (< (length ,s) ,n)
         (debug0 'tos-list
           ("stack is not long enough : ~a~%" (quote ,s))
           ("stack length : ~a~%" (length ,s))
           ("need length : ~a~%" ,n))
         (take ,s ,n)))
    #+end_src

*** note

    #+begin_src scheme
    (: ns {(name . meaning) ...})
    (: ds {data ...})
    (: bs {(id . ls) ...})
    (: rs {rsp ...})
    (: gs {gsp ...})
    #+end_src

*** print-jo

    #+begin_src scheme
    (define (print-jo j)
      (match j
        [{'var n}  (cat ("~a " n))]
        [{'fvar n} (cat (":~a " n))]
        [{'bind n} (cat ("%~a " n))]
        [{'call n} (cat ("~a " n))]
        [{'arrow nl fnl ajj sjj}
         (cat ("(-> "))
         (cat ("[ ")) (map print-jo ajj) (cat ("] "))
         (cat ("[ ")) (map print-jo sjj) (cat ("]) "))]
        [{'uni-arrow nl frc ajj sjj}
         (cat ("(-> "))
         (cat ("[ ")) (map print-jo ajj) (cat ("] "))
         (cat ("[ ")) (map print-jo sjj) (cat ("]) "))]
        [{'lambda a al}
         (cat ("(lambda "))
         (print-jo a)
         (map print-jo al)
         (cat (") "))]
        [{'uni-lambda a al}
         (cat ("(lambda "))
         (print-jo a)
         (map print-jo al)
         (cat (") "))]
        [{'apply}
         (cat ("@ "))]))
    #+end_src

*** print-data

    #+begin_src scheme
    (define (print-data d)
      (match d
        [{'uni-var id level}
         (let* ([p (vector-ref id 0)]
                [n (car p)]
                [c (cdr p)]
                [ls (vector-ref id 1)])
           (cat ("(~a #~a ^~a" n c level))
           (print-ls ls)
           (cat (") ")))]
        [{'uni-bind uv d}
         (cat ("(:%: "))
         (print-data uv)
         (print-data d)
         (cat (") "))]
        [{'cons n dl}
         (if3 [(null? dl)]
              [(cat ("~a " n))]
              [(cat ("[ ~a " n))
               (map print-data dl)
               (cat ("] "))])]
        [('uni-arrow . __)
         (print-jo d)]
        [('uni-lambda . __)
         (print-jo d)]
        [{'trunk adl sdl k i}
         (cat ("(:trunk: #~a " i))
         (map print-data adl)
         (map print-data sdl)
         (cat ("~a) " k))]))
    #+end_src

*** print-bsp

    #+begin_src scheme
    ;; note that
    ;;   bsp can be '(commit-point)
    (: bs {(id . ls) ...})
    (: id (vector (name . counter) ls))
    (: ls {(level . data) ...})

    (define (print-bsp bsp)
      (print-id (car bsp))
      (cat ("~%"))
      (cat ("  ")) (print-ls (cdr bsp))
      (cat ("~%")))

    (define (print-id id)
      (let* ([p (vector-ref id 0)]
             [n (car p)]
             [c (cdr p)]
             [ls (vector-ref id 1)])
        (cat ("~a #~a " n c)) (print-ls ls)))

    (define (print-lsp lsp)
      (let ([level (car lsp)]
            [d (cdr lsp)])
        (cat (":~a: " level))
        (print-data d)))

    (define (print-ls ls)
      (map print-lsp ls))
    #+end_src

*** print-nsp

    #+begin_src scheme
    (define (print-nsp nsp)
      (let ([n0 (car nsp)]
            [meaning (cdr nsp)])
        (cat ("~a~%" n0))
        (match meaning
          [{'meaning-type a n nl}
           (cat ("  :type: ")) (print-jo a) (cat ("~%"))
           (cat ("  :constructor: ~a~%" nl))]
          [{'meaning-data a n n0}
           (cat ("  :type: ")) (print-jo a) (cat ("~%"))
           (cat ("  :belong-to: ~a~%" n0)) ]
          [{'meaning-lambda a al}
           (cat ("  :type: ")) (print-jo a) (cat ("~%"))
           (cat ("  :lambda: ")) (map print-jo al) (cat ("~%"))])
        (cat ("~%"))))
    #+end_src

*** print ds bs ns rs gs

    #+begin_src scheme
    (define (print-ds)
      (if3 [(null? ds)]
           [(cat ("~%<ds>~%</ds>~%~%"))]
           [(cat ("~%<ds>~%"))
            (cat ("  ")) (map print-data ds)
            (cat ("~%</ds>~%~%"))]))

    (define (print-bs)
      (cat ("~%<bs>~%"))
      (map print-bsp bs)
      (cat ("</bs>~%~%")))

    (define (print-ns)
      (cat ("~%<ns>~%"))
      (map print-nsp ns)
      (cat ("</ns>~%~%")))

    (define (print-rs)
      (cat ("~%<rs>~%"))
      (map (lambda (o) (@ o 'print)) rs)
      (cat ("</rs>~%~%")))

    (define (print-gs)
      (cat ("~%<gs>~%"))
      (map (lambda (o) (@ o 'print)) gs)
      (cat ("</gs>~%~%")))
    #+end_src

*** print-env

    #+begin_src scheme
    (define (print-env)
      (print-ds)
      (print-rs)
      (print-gs)
      (print-bs))
    #+end_src

*** clear-env

    #+begin_src scheme
    (define (clear-env)
      (set! ds '())
      (set! rs '())
      (set! gs '())
      (set! bs '()))
    #+end_src

*** clear-world

    #+begin_src scheme
    (define (clear-world)
      (clear-env)
      (set! ns '()))
    #+end_src

* ns

*** ns

    #+begin_src scheme
    ;; name-stack
    (define ns '())
    (: ns {(name . meaning) ...})
    #+end_src

*** note meaning

    #+begin_src scheme
    (: meaning
       meaning-type       uni-arrow name {name ...}
       meaning-data       uni-arrow name name
       meaning-lambda     uni-arrow {uni-arrow ...})
    #+end_src

*** compile

***** note

      - we need two passes to generate the local in arrow
        pass1 for arrow without local
        pass2 for local

***** compile-arrow

      #+begin_src scheme
      (define (compile-arrow a)
        (pass2-arrow (pass1-arrow a)))
      #+end_src

***** compile-uni-arrow

      #+begin_src scheme
      (define (compile-uni-arrow a)
        (match (compile-arrow a)
          [{'arrow nl fnl ajj sjj}
           (if (null? fnl)
             {'uni-arrow nl '() ajj sjj}
             (debug0 'compile-uni-arrow
               ("the free-var-name-list of arrow is not empty~%")
               ("free-var-name-list : ~a~%" fnl)
               ("arrow : ~a~%" a)))]))
      #+end_src

***** compile-jo

      #+begin_src scheme
      (define (compile-jo j)
        (pass2-jo (pass1-jo j)))
      #+end_src

***** pass1-jo

      #+begin_src scheme
      (define (pass1-jo jo)
        (define (var? v)
          (and (symbol? v)
               (eq? ': (symbol-car v))
               (not (eq? ': (symbol-car (symbol-cdr v))))))
        (define (fvar? v)
          (and (symbol? v)
               (eq? ': (symbol-car v))
               (eq? ': (symbol-car (symbol-cdr v)))))
        (define (bind? v)
          (and (symbol? v)
               (eq? '% (symbol-car v))
               (eq? ': (symbol-car (symbol-cdr v)))))
        (define (apply? v)
          (eq? v '@))
        (define (call? v)
          (and (symbol? v)
               (not (eq? ': (symbol-car v)))
               (not (eq? '% (symbol-car v)))))
        (define (arrow? v)
          (and (list? v)
               (pair? v)
               (eq? (car v) '->)))
        (define (lambda? v)
          (and (list? v)
               (pair? v)
               (eq? (car v) 'lambda)))
        (cond [(var? jo)                (list 'var jo)]
              [(fvar? jo)               (list 'fvar (symbol-cdr jo))]
              [(bind? jo)               (list 'bind (symbol-cdr jo))]
              [(apply? jo)              (list 'apply)]
              [(call? jo)               (list 'call jo)]
              [(arrow? jo)              (pass1-arrow jo)]
              [(lambda? jo)             (list 'lambda
                                              (pass1-arrow (car (cdr jo)))
                                              (map pass1-arrow (cdr (cdr jo))))]))
      #+end_src

***** pass1-arrow

      #+begin_src scheme
      (define (pass1-arrow a)
        (match a
          [{'-> ac sc}
           {'arrow (map pass1-jo ac) (map pass1-jo sc)}]))
      #+end_src

***** pass2-jo

      #+begin_src scheme
      (define (pass2-jo jo)
        (match jo
          [{'arrow ac sc} (pass2-arrow jo)]
          [{'lambda a al} {'lambda (pass2-arrow a) (map pass2-arrow al)}]
          [__ jo]))
      #+end_src

***** pass2-arrow

      #+begin_src scheme
      (define (pass2-arrow a)
        (match a
          [{'arrow ac sc}
           {'arrow (jojo->var-list (append ac sc))
                   (jojo->fvar-list (append ac sc))
                   (map pass2-jo ac) (map pass2-jo sc)}]))
      #+end_src

***** jojo->var-list

      #+begin_src scheme
      (define (jojo->var-list l)
        (define (one vl n)
          (if (member n vl)
            vl
            (cons n vl)))
        (define (more vl jo)
          (match jo
            [{'var n}         (one vl n)]
            [{'fvar n}        vl]
            [{'bind n}        (one vl n)]
            [{'call n}        vl]
            [{'apply}         vl]
            [{'arrow ac sc}   (loop vl (append ac sc))]
            [{'lambda a al}   (arrow-loop vl (cons a al))]))
        (define (arrow-loop vl l)
          (if (null? l)
            vl
            (match (car l)
              [{'arrow ac sc}
               (arrow-loop (loop vl (append ac sc)) (cdr l))])))
        (define (loop vl l)
          (if (null? l)
            vl
            (loop (more vl (car l)) (cdr l))))
        (loop '() l))
      #+end_src

***** jojo->fvar-list

      #+begin_src scheme
      (define (jojo->fvar-list l)
        (define (one vl n)
          (if (member n vl)
            vl
            (cons n vl)))
        (define (more vl jo)
          (match jo
            [{'var n}         vl]
            [{'fvar n}        (one vl n)]
            [{'bind n}        vl]
            [{'call n}        vl]
            [{'apply}         vl]
            ;; arrow and lambda block the search of ::name
            [{'arrow ac sc}   vl]
            [{'lambda a al}   vl]))
        (define (arrow-loop vl l)
          (if (null? l)
            vl
            (match (car l)
              [{'arrow ac sc}
               (arrow-loop (loop vl (append ac sc)) (cdr l))])))
        (define (loop vl l)
          (if (null? l)
            vl
            (loop (more vl (car l)) (cdr l))))
        (loop '() l))
      #+end_src

* ds

*** ds

    #+begin_src scheme
    ;; data-stack
    (define ds '())
    (: ds {data ...})
    #+end_src

*** call-with-output-to-new-ds

    #+begin_src scheme
    (define (call-with-output-to-new-ds f)
      (: function -> new-ds)
      (let ([ds-backup ds])
        (set! ds '())
        (f)
        (let ([new-ds ds])
          (set! ds ds-backup)
          new-ds)))
    #+end_src

* bs

*** bs

    #+begin_src scheme
    ;; binding-stack
    (define bs '())
    (: bs {(id . ls) ...})
    #+end_src

*** bs/commit & id/commit

    #+begin_src scheme
    (define (bs/commit)
      (define (recur bs0)
        (cond [(equal? '(commit-point) (car bs0))
               (set! bs (cdr bs0))]
              [else
               (let ([id (car (car bs0))]
                     [ls (cdr (car bs0))])
                 (id/commit id ls)
                 (recur (cdr bs0)))]))
      (recur bs))

    (define (id/commit id ls)
      (: id ls -> id [with effect on id])
      (let ()
        (vector-set! id 1 (append ls (vector-ref id 1)))
        id))
    #+end_src

*** bs/extend & bs/extend-up

    #+begin_src scheme
    (define (bs/extend uv d)
      (: uni-var data -> !)
      (match uv
        [{'uni-var id level}
         (let ([found/ls (assq id bs)])
           (if found/ls
             (set! bs (substitute `(,id . ((,level . ,d) . ,(cdr found/ls)))
                                  (lambda (pair) (eq? (car pair) id))
                                  bs))
             (push bs `(,id . ((,level . ,d))))))]))

    (define (bs/extend-up uv d)
      (: uni-var data -> !)
      (match uv
        [{'uni-var id level}
         (let ([level (+ 1 level)]
               [found/ls (assq id bs)])
           (if found/ls
             (set! bs (substitute `(,id . ((,level . ,d) . ,(cdr found/ls)))
                                  (lambda (pair) (eq? (car pair) id))
                                  bs))
             (push bs `(,id . ((,level . ,d))))))]))

    ;; in compose/var
    ;;   extend bs whenever meet a new var
    ;;   this helps commit

    ;; not using ><><><
    (define (bs/extend-new uv d)
      (: uni-var data -> !)
      (match uv
        [{'uni-var id level}
         (push bs `(,id . ((,level . ,d))))]))

    ;; (define (bs/extend-new v d)
    ;;   (: var data -> !)
    ;;   (match v
    ;;     [{'uni-var id level}
    ;;      (let ([found/ls (assq id bs)])
    ;;        (if found/ls
    ;;          (void)
    ;;          (push bs `(,id . ()))))]))
    #+end_src

*** bs/find & bs/find-up

    #+begin_src scheme
    (define (id->ls id)
      (vector-ref id 1))

    (define (bs/find uv)
      (: uni-var -> (or data #f))
      (match uv
        [{'uni-var id level}
         (let* ([found/commit (assq level (id->ls id))])
           (if found/commit
             (cdr found/commit)
             (let* ([found/ls (assq id bs)]
                    [found/bind
                     (if found/ls
                       (assq level (cdr found/ls))
                       #f)])
               (if found/bind
                 (cdr found/bind)
                 #f))))]))

    (define (bs/find-up uv)
      (: uni-var -> (or data #f))
      (match uv
        [{'uni-var id level}
         (let* ([level (+ 1 level)]
                [found/commit (assq level (id->ls id))])
           (if found/commit
             (cdr found/commit)
             (let* ([found/ls (assq id bs)]
                    [found/bind
                     (if found/ls
                       (assq level (cdr found/ls))
                       #f)])
               (if found/bind
                 (cdr found/bind)
                 #f))))]))
    #+end_src

*** bs/walk

    #+begin_src scheme
    (define (bs/walk d)
      (: data -> data)
      (match d
        [{'uni-var id level}
         (let ([found (bs/find d)])
           (if found
             (bs/walk found)
             d))]
        [__ d]))
    #+end_src

*** bs/deep

    #+begin_src scheme
    (define (bs/deep d)
      (: data -> data)
      (let ([d (bs/walk d)])
        (match d
          ;; a uni-var is fresh after bs/walk
          [{'cons n dl}          {'cons n (bs/deep-list dl)}]
          [{'uni-bind uv d}      {'bind (bs/deep uv) (bs/deep d)}]
          [{'trunk adl sdl k i}  {'trunk (bs/deep-list adl)
                                         (bs/deep-list sdl)
                                         (bs/deep-trunky k) i}]
          [__                    d])))

    (define (bs/deep-list dl)
      (map (lambda (x) (bs/deep x)) dl))

    (define (bs/deep-trunky k)
      (vector-set!
        k 0
        (match (vector-ref k 0)
          [{'todo al dl} {'todo al (bs/deep-list dl)}]
          [{'kvar kv dl} {'kvar (bs/deep kv) (bs/deep-list dl)}]
          [{'done dl}    {'done (bs/deep-list dl)}]))
      k)
    #+end_src

*** uni-var/fresh?

    #+begin_src scheme
    (define (uni-var/fresh? uv)
      (: uni-var -> bool)
      (equal? (bs/walk uv)
              uv))
    #+end_src

*** uni-var/eq?

    #+begin_src scheme
    (define (uni-var/eq? v1 v2)
      (match {v1 v2}
        [{{'uni-var id1 level1} {'uni-var id2 level2}}
         (and (eq? id1 id2)
              (eq? level1 level2))]))
    #+end_src

* rs

*** rs

    #+begin_src scheme
    ;; return-stack
    (define rs '())
    #+end_src

*** rs/next

    #+begin_src scheme
    (define (rs/next)
      (if rs/steper-flag
        (rs/steper)
        (rs/next/call-ex)))
    #+end_src

*** rs/steper

    #+begin_src scheme
    (define rs/steper-flag #f)
    (define rs/steper-counter 0)
    (define (rs/steper+) (set! rs/steper-flag #t))
    (define (rs/steper-) (set! rs/steper-flag #f))

    (define (rs/steper)
      (cat ("rs/steper> "))
      (if (> rs/steper-counter 0)
        (let ()
          (set! rs/steper-counter (- rs/steper-counter 1))
          (cat (":~a:~%" rs/steper-counter))
          (print-rs)
          (rs/next/call-ex))
        (let ([user-input (read)])
          (cond [(number? user-input)
                 (set! rs/steper-counter user-input)
                 (cat (":~a:~%" rs/steper-counter))
                 (print-rs)
                 (rs/next/call-ex)]
                [(eq? user-input 'n)
                 (cat (":~a:~%" rs/steper-counter))
                 (print-rs)
                 (rs/next/call-ex)]
                [(eq? user-input 'exit)
                 (cat ("rs/steper: exit~%"))
                 (rs/steper-)
                 (rs/next/call-ex)]
                [else
                 (cat ("rs/steper: unknown command :: ~a~%" user-input))
                 (rs/steper)]))))
    #+end_src

*** rs/next/call-ex

    #+begin_src scheme
    (define (rs/next/call-ex)
      (let ([ex (^ (tos rs) 'ex)])
        (ex)))
    #+end_src

*** print-vrcp

    #+begin_src scheme
    (define (print-vrcp vrcp)
      (let* ([n (car vrcp)]
             [v (cdr vrcp)])
        (cat ("      ~a " n))
        (print-data v)
        (cat ("~%"))))
    #+end_src

*** rsp-proto

    #+begin_src scheme
    (define rsp-proto
      (new-object
       (pair-list
        'c      0
        'ex     '(explainer)
        'vrc    '(var record)
        'jj     '(jojo))
       (pair-list
        'print
        (lambda (o)
          (cat ("  <rsp>~%")
               ("    :counter: ~a~%" (^ o 'c))
               ("    :var-record:~%"))
          (map print-vrcp (^ o 'vrc))
          (cat ("    :jojo: "))
          (map print-jo (^ o 'jj))
          (cat ("~%"))
          (cat ("  </rsp>~%"))))))
    #+end_src

*** id/new

    #+begin_src scheme
    (define id/counter 0)

    ;; (define (id/new n ls)
    ;;   (set! id/counter (+ 1 id/counter))
    ;;   (vector (cons n id/counter) ls))

    (define (id/new n)
      (set! id/counter (+ 1 id/counter))
      (vector (cons n id/counter) '()))
    #+end_src

*** nl->vrc

    #+begin_src scheme
    (define (nl->vrc nl)
      (map (lambda (n)
             (cons n (list 'uni-var (id/new n) 0)))
        nl))
    #+end_src

*** name->uni-var

    #+begin_src scheme
    (define (name->uni-var n)
      (let* ([rsp (tos rs)]
             [found (assq n (^ rsp 'vrc))])
        (if found
          (cdr found)
          (debug0 'name->uni-var
            ("can not find name : ~a~%" n)
            ("rsp var record : ~a~%" (^ rsp 'vrc))))))
    #+end_src

*** name->fvar-record

    #+begin_src scheme
    (define (name->fvar-record n)
      (let* ([rsp (tos rs)]
             [found (assq n (^ rsp 'vrc))])
        (if found
          (cons n (cdr found))
          (debug0 'name->fvar-record
            ("can not find name : ~a~%" n)
            ("rsp var record : ~a~%" (^ rsp 'vrc))))))
    #+end_src

*** fnl->frc

    #+begin_src scheme
    (define (fnl->frc fnl)
      (map name->fvar-record fnl))
    #+end_src

*** compose

***** compose

      #+begin_src scheme
      (define (compose)
        (let* ([rsp (pop rs)]
               [c   (^ rsp 'c)]
               [ex  (^ rsp 'ex)]
               [jj  (^ rsp 'jj)])
          (if3 [(>= c (length jj))]
               []
               [(push rs (% rsp 'c (+ 1 c)))
                (compose/jo (list-ref jj c))
                (rs/next)])))
      #+end_src

***** compose/jo

      #+begin_src scheme
      (define (compose/jo j)
        (case (car j)
          ['var           (compose/var j)]
          ['fvar          (compose/var j)]
          ['bind          (compose/bind j)]
          ['call          (compose/call j)]
          ['arrow         (compose/arrow j)]
          ['lambda        (compose/lambda j)]
          ['apply         (compose/apply j)]))
      #+end_src

***** compose/var

      #+begin_src scheme
      (define (compose/var j)
        ;; (if (uni-var/fresh? j)
        ;;   (bs/extend-new j))
        (let* ([n (match j
                    [{'var n} n]
                    [{'fvar n} n])]
               [uv (name->uni-var n)]
               [d (bs/deep uv)])
          (push ds d)))
      #+end_src

***** compose/bind

      #+begin_src scheme
      (define (compose/bind j)
        (match j
          [{'bind n}
           (let* ([uv (name->uni-var n)]
                  [d (pop ds)])
                  (bs/extend-up uv d)
             (push ds {'uni-bind uv d}))]))
      #+end_src

***** compose/call

      #+begin_src scheme
      (define (compose/call j)
        (match j
          [{'call n}
           (let ([found (assq n ns)])
             (if (not found)
               (debug0 'compose/call ("unknow name : ~a~%" n))
               (match (cdr found)
                 [{'meaning-type a n nl} (compose/cons n a)]
                 [{'meaning-data a n n0} (compose/cons n a)]
                 [{'meaning-lambda a al} (compose/body a al)])))]))
      #+end_src

***** compose/cons

      #+begin_src scheme
      (define (compose/cons n a)
        (let* ([tdl (match a
                      [{'uni-arrow nl frc ajj sjj}
                       (call-with-output-to-new-ds
                        (lambda ()
                          (push rs (% rsp-proto
                                      'ex   compose
                                      'vrc  (append frc (nl->vrc nl))
                                      'jj   ajj))
                          (rs/next)))])]
               [dl (pop-list ds (length tdl))])
          (if3 [(push gs (% gsp-proto
                            'ex *up-unify*
                            'dl+ (reverse dl)
                            'dl- (reverse tdl)))
                (gs/next)]
               [(push ds (list 'cons n dl))]
               [(debug0 'compose/cons
                  ("unify fail~%")
                  ("dl : ~a~%" dl)
                  ("tdl : ~a~%" tdl))])))
      #+end_src

***** compose/body

******* compose/body

        #+begin_src scheme
        (: [for the first covering arrow]
           (push gs {cover commit
                           <data-on-the-stack>
                           (push rs {compose exit <ac>})})
           (cond [(succ?)
                  (commit)
                  (push rs {compose exit <sc>})
                  (exit)]
                 [(fail?)
                  (undo)
                  (loop)])
           (if (all-fail?) (form-trunk)))

        (define (compose/body t b)
          ;; note that
          ;;   when create-trunk-list
          ;;   it needs to know the type to get input-number & output-numbe
          ;; note that
          ;;   compose/body can not fail
          ;;   at least trunk is created
          (: type body -> [:ds (or [result of body]
                                   [trunk generated by body])])
          (match t
            [{'uni-arrow nl frc ajj sjj}
             (let* ([tvrc (append frc (nl->vrc nl))]
                    [tdl (call-with-output-to-new-ds
                          (lambda ()
                            (push rs (% rsp-proto
                                        'ex   compose
                                        'vrc  tvrc
                                        'jj   ajj))
                            (rs/next)))]
                    [dl (tos-list ds (length tdl))])
               (if3 [(push gs (% gsp-proto
                                 'ex *up-unify*
                                 'dl+ (reverse dl)
                                 'dl- (reverse tdl)))
                     (gs/next)]
                    [(match (compose/try-body b)
                       [{sjj vrc}
                        (push rs (% rsp-proto
                                    'ex   compose
                                    'vrc  vrc
                                    'jj   sjj))
                        (rs/next)]
                       [#f
                        (let ([dl (pop-list ds (type/input-number t))])
                          (push-list ds (create-trunk-list t b dl)))])]
                    [(debug0 'compose/body
                       ("up-unify fail~%")
                       ("dl  : ~a~%" dl)
                       ("tdl : ~a~%" tdl))]))]))
        #+end_src

******* compose/try-body

        #+begin_src scheme
        (define (compose/try-body b)
          (: body -> (or #f {sjj vrc}))
          ;; return #f on fail
          ;; return sjj on success with commit
          (match b
            [{} #f]
            [({'uni-arrow nl frc ajj sjj} . r)
             (let* ([vrc (append frc (nl->vrc nl))]
                    [ds0 ds]
                    [bs0 bs]
                    [gs0 gs]
                    [dl1 (call-with-output-to-new-ds
                          (lambda ()
                            (push rs (% rsp-proto
                                        'ex   compose
                                        'vrc  vrc
                                        'jj   ajj))
                            (rs/next)))]
                    [dl2 (pop-list ds (length dl1))])
               (if3 [(push bs '(commit-point))
                     (push gs (% gsp-proto
                                 'ex   *cover*
                                 'dl+  (reverse dl1)
                                 'dl-  (reverse dl2)))
                     (gs/next)]
                    ;; commit or undo
                    [(bs/commit)
                     {sjj vrc}]
                    [(set! ds ds0)
                     (set! bs bs0)
                     (set! gs gs0)
                     (compose/try-body r)]))]))
        #+end_src

******* create-trunk-list

        #+begin_src scheme
        ;; ><><><
        ;; need after-d2t-unify for adl and dl
        (define (create-trunk-list t b dl)
          (match t
            [{'uni-arrow nl frc ajj sjj}
             (let* ([vrc (append frc (nl->vrc nl))]
                    [adl (call-with-output-to-new-ds
                          (lambda ()
                            (push rs (% rsp-proto
                                        'ex   compose
                                        'vrc  vrc
                                        'jj   ajj))
                            (rs/next)))]
                    [sdl (call-with-output-to-new-ds
                          (lambda ()
                            (push rs (% rsp-proto
                                        'ex   compose
                                        'vrc  vrc
                                        'jj   sjj))
                            (rs/next)))]
                    [k (match b
                         [('uni-var . __)
                          (vector {'kvar b dl})]
                         [__
                          (vector {'todo b dl})])])
               (reverse
                (map (lambda (i) {'trunk adl sdl k i})
                  (genlist (length sdl)))))]))
        #+end_src

******* type/input-number & type/output-number

        #+begin_src scheme
        (define (type/input-number t)
          (match t
            [{'uni-arrow nl frc ajj sjj}
             (length (call-with-output-to-new-ds
                      (lambda ()
                        (push rs (% rsp-proto
                                    'ex   compose
                                    'vrc  (append frc (nl->vrc nl))
                                    'jj  ajj))
                        (rs/next))))]))

        (define (type/output-number t)
          (match t
            [{'uni-arrow nl frc ajj sjj}
             (length (call-with-output-to-new-ds
                      (lambda ()
                        (push rs (% rsp-proto
                                    'ex   compose
                                    'vrc  (append frc (nl->vrc nl))
                                    'jj  sjj))
                        (rs/next))))]))
        #+end_src

***** arrow->uni-arrow

      #+begin_src scheme
      (define (arrow->uni-arrow a)
        (match a
          [{'arrow nl fnl ajj sjj}
           {'uni-arrow nl (fnl->frc fnl) ajj sjj}]))
      #+end_src

***** compose/arrow

      #+begin_src scheme
      (define (compose/arrow j)
        (push ds (arrow->uni-arrow j)))
      #+end_src

***** compose/lambda

      #+begin_src scheme
      (define (compose/lambda j)
        (match j
          [{'lambda a al}
           (push ds {'uni-lambda (arrow->uni-arrow a)
                                 (map arrow->uni-arrow al)})]))
      #+end_src

***** ><>< compose/apply

      #+begin_src scheme
      ;; note that
      ;;   compose/apply can form trunk too
      ;;   the body of trunk formed by apply is uni-var
      (define (compose/apply j)
        (let ([d (bs/walk (pop ds))])
          (match d
            [{'uni-lambda t b}
             (compose/body t b)]
            [{'uni-var id level}
             (let* ([t (d2t d)]
                    [b d])
               (match t
                 [{'uni-arrow nl frc ajj sjj}
                  (let ([dl (pop-list ds (type/input-number t))])
                    (push-list ds (create-trunk-list t b dl)))]
                 [__ (debug0 'compose/apply
                       ("compose/apply meet uni-var whoes type is not uni-arrow~%")
                       ("uni-var : ~a~%" d)
                       ("type of uni-var : ~a~%" t))]))]
            [__ (debug0 'compose/apply
                  ("compose/apply can not apply data~%")
                  ("data : ~a~%" d))])))
      #+end_src

* gs

*** gs

    #+begin_src scheme
    ;; goal-stack
    ;;   binding-stack is to record solution of equations in goal-stack
    (define gs '())
    #+end_src

*** gs/next

    #+begin_src scheme
    (define (gs/next)
      (: -> bool)
      (if gs/steper-flag
        (gs/steper)
        (gs/next/call-ex)))
    #+end_src

*** gs/steper

    #+begin_src scheme
    (define gs/steper-flag #f)
    (define gs/steper-counter 0)
    (define (gs/steper+) (set! gs/steper-flag #t))
    (define (gs/steper-) (set! gs/steper-flag #f))

    (define (gs/steper)
      (: -> bool)
      (cat ("gs/steper> "))
      (if (> gs/steper-counter 0)
        (let ()
          (set! gs/steper-counter (- gs/steper-counter 1))
          (cat (":~a:~%" gs/steper-counter))
          (print-gs)
          (gs/next/call-ex))
        (let ([user-input (read)])
          (cond [(number? user-input)
                 (set! gs/steper-counter user-input)
                 (cat (":~a:~%" gs/steper-counter))
                 (print-gs)
                 (gs/next/call-ex)]
                [(eq? user-input 'n)
                 (cat (":~a:~%" gs/steper-counter))
                 (print-gs)
                 (gs/next/call-ex)]
                [(eq? user-input 'exit)
                 (cat ("gs/steper: exit~%"))
                 (gs/steper-)
                 (gs/next/call-ex)]
                [else
                 (cat ("gs/steper: unknown command :: ~a~%" user-input))
                 (gs/steper)]))))
    #+end_src

*** gs/next/call-ex

    #+begin_src scheme
    (define (gs/next/call-ex)
      (: -> bool)
      (let* ([p (^ (tos gs) 'ex)]
             [ex (cdr p)])
        (ex)))
    #+end_src

*** gsp-proto

    #+begin_src scheme
    (define gsp-proto
      (new-object
       (pair-list
        'c      0
        'ex     '(explainer)
        'dl+    '(data-list)
        'dl-    '(data-list))
       (pair-list
        'print
        (lambda (o)
          (cat ("  <gsp>~%")
               ("    :counter: ~a~%"   (^ o 'c))
               ("    :explainer: ~a~%" (car (^ o 'ex))))
          (cat ("    :double-data-list:~%"))
          (map (lambda (d+ d-)
                 (cat ("      :+: "))
                 (print-data d+)
                 (cat (":-: "))
                 (print-data d-)
                 (cat ("~%")))
            (^ o 'dl+) (^ o 'dl-))
          (cat ("  </gsp>~%"))))))
    #+end_src

*** ><><>< d2t

    #+begin_src scheme
    (define (d2t d)
      (define (a->sdl a)
        (match a
          [{'uni-arrow nl frc ajj sjj}
           (let* ([vrc (append frc (nl->vrc nl))]
                  [adl (call-with-output-to-new-ds
                        (lambda ()
                          (push rs (% rsp-proto
                                      'ex   compose
                                      'vrc  vrc
                                      'jj   sjj))
                          (rs/next)))]
                  [sdl (call-with-output-to-new-ds
                        (lambda ()
                          (push rs (% rsp-proto
                                      'ex   compose
                                      'vrc  vrc
                                      'jj   sjj))
                          (rs/next)))])
             sdl)]))
      (match d
        [{'uni-var id level} (bs/walk {'uni-var id (+ 1 level)})]
        [{'uni-bind uv d1} d1]
        [{'cons n dl}
         (let ([found (assq n ns)])
           (if (not found)
             (debug0 'd2t ("unknow name : ~a~%" n))
             (match (cdr found)
               ;; ><><><
               ;; need bind-unify for adl of cons and dl
               [{'meaning-type a n nl}
                (car (a->sdl a))]
               [{'meaning-data a n n0}
                (car (a->sdl a))]
               [{'meaning-lambda a al}
                (debug0 'd2t
                  ("found a lambda from cons name : ~a~%" n)
                  ("lambda type : ~a~%" a)
                  ("lambda body : ~a~%" al))])))]
        [('uni-arrow . __)
         (debug0 'd2t
           ("can not infer type from uni-arrow : ~a~%" d))]
        [{'uni-lambda a al} a]
        [{'trunk adl sdl k i}
         ;; info about special branch is not needed
         ;;   thus no need to try-trunk
         ;; info about the dl is needed
         ;;   it is already handled when creating the trunk
         (list-ref sdl i)]))
    #+end_src

*** unify

***** note cover

      - cover is the poset structure of term-lattice (subsumption-lattice)

      - only recur into data
        but not jo

***** note unify

      - almost the same code as cover

      - this is the meet (greatest lower bound) operation of term-lattice

      - first order syntactic unification

      - for unify/trunk
        first syntactic unification is tried
        if it fail
        semantic unification is used

      - except for unify/trunk/data
        semantic unification (unification modulo theory) is tried
        try (trunk -> redex)
        (computation can occur in type-check)

      - no substitutional equality
        (no second order semantic unification)
        (but can use proved '=' to get explicit substitutional equality)

***** note the equal? of scheme can handle circle

      #+begin_src scheme
      (: (let ([p1 (cons 1 1)]
               [p2 (cons 1 1)])
           (set-cdr! p1 p1)
           (set-cdr! p2 p2)
           (list p1 p2 (equal? p1 p2))))
      (: (#0=(1 . #0#) #1=(1 . #1#) #t))
      #+end_src

***** unify

      #+begin_src scheme
      (define (unify m)
        (: method -> (-> bool))
        (lambda ()
          (let* ([gsp (pop gs)]
                 [c   (^ gsp 'c)]
                 [ex  (^ gsp 'ex)]
                 [dl1 (^ gsp 'dl+)]
                 [dl2 (^ gsp 'dl-)])
            (if3 [(>= c (length dl1))]
                 [#t]
                 [(push gs (% gsp 'c (+ 1 c)))
                  (if (unify/data/data m
                                       (list-ref dl1 c)
                                       (list-ref dl2 c))
                    (gs/next)
                    #f)]))))
      #+end_src

***** unify/data/data

      #+begin_src scheme
      (define (unify/data/data m d1 d2)
        (: data data -> bool)
        ;; var -walk-> fresh-var
        (let ([d1 (bs/walk d1)]
              [d2 (bs/walk d2)])
          (match {d1 d2}
            ;; ignore the sub-data
            ;;   for it is used by top-level type-check
            [{{'uni-bind uv d} __} (unify/data/data m d d2)]
            [{__ {'uni-bind uv d}} (unify/data/data m d1 d)]

            ;; var is the hero
            ;; this should pass occur-check
            [{{'uni-var id1 level1} {'uni-var id2 level2}}
             (cond [(uni-var/eq? d1 d2) #t] ;; no self-unify
                   [else (unify/uni-var/data m d1 d2)])]

            [{{'trunk adl sdl k i} {'uni-var id level}} (unify/trunk/uni-var m d1 d2)]
            [{{'uni-var id level} {'trunk adl sdl k i}} (unify/uni-var/trunk m d1 d2)]

            [{{'uni-var id level} __} (unify/uni-var/data m d1 d2)]
            [{__ {'uni-var id level}} (unify/data/uni-var m d1 d2)]

            ;; cons push gs
            [{{'cons n1 dl1} {'cons n2 dl2}}
             (cond [(eq? n1 n2)
                    (push gs (% gsp-proto
                                'ex *unify*
                                'dl+ (reverse dl1)
                                'dl- (reverse dl2)))
                    (gs/next)]
                   [else #f])]

            ;; trunk is the tricky part
            ;;   semantic equal is used
            [{{'trunk adl1 sdl1 k1 i1} {'trunk adl2 sdl2 k2 i2}}
             (unify/trunk/trunk m d1 d2)]
            [{{'trunk adl sdl k i} __} (unify/trunk/data m d1 d2)]
            [{__ {'trunk adl sdl k i}} (unify/data/trunk m d1 d2)]

            [{{'uni-arrow nl1 frc1 ajj1 sjj1}
              {'uni-arrow nl2 frc2 ajj2 sjj2}}
             (unify/arrow/arrow m d1 d2)]

            ;; others use syntax equal
            [{__ __} (equal? d1 d2)])))
      #+end_src

***** unify/uni-var/data

      #+begin_src scheme
      (define (unify/uni-var/data m uv d)
        (: fresh-var data -> bool)
        ;; no consistent-check
        ;;   because we do not have infer
        (if (occur-check/data uv d)
          (bs/extend uv d)
          #f))
      #+end_src

***** unify/data/uni-var

      #+begin_src scheme
      (define (unify/data/uni-var m d uv)
        (: fresh-var data -> bool)
        ;; no consistent-check
        ;;   because we do not have infer
        (case m
          ['cover #f]
          ['unify (if (occur-check/data uv d)
                    (bs/extend uv d)
                    #f)]))
      #+end_src

***** unify/trunk/uni-var

      #+begin_src scheme
      (define (unify/trunk/uni-var m t uv)
        (: trunk fresh-uni-var -> bool)
        (let ([result (try-trunk t)])
          (if result
            (unify/data/data m result uv)
            (case m
              ['cover #f]
              ['unify (unify/data/uni-var m t uv)]))))
      #+end_src

***** unify/uni-var/trunk

      #+begin_src scheme
      (define (unify/uni-var/trunk m uv t)
        (: fresh-uni-var trunk -> bool)
        (let ([result (try-trunk t)])
          (if result
            (unify/data/data m uv result)
            (unify/uni-var/data m uv t))))
      #+end_src

***** unify/trunk/data

      #+begin_src scheme
      (define (unify/trunk/data m t d)
        (let ([result (try-trunk t)])
          (if result
            (unify/data/data m result d)
            #f)))
      #+end_src

***** unify/data/trunk

      #+begin_src scheme
      (define (unify/data/trunk m d t)
        (let ([result (try-trunk t)])
          (if result
            (unify/data/data m d result)
            #f)))
      #+end_src

***** >< unify/trunk/trunk

      #+begin_src scheme
      (define (unify/trunk/trunk m t1 t2)
        (let ([result1 (try-trunk t1)]
              [result2 (try-trunk t2)])
          (cond [result1 (unify/data/trunk m result1 t2)]
                [result2 (unify/trunk/data m t1 result2)]
                [else
                 ;; when both fail to try-trunk
                 ;;   still have chance to syntax equal
                 (match {t1 t2}
                   [{{'trunk adl1 sdl1 k1 i1} {'trunk adl2 sdl2 k2 i2}}
                    (match {(vector-ref k1 0) (vector-ref k2 0)}
                      [{{'todo b1 dl1} {'todo b2 dl2}}
                       (if3 [(equal? {adl1 sdl1 i1 b1}
                                     {adl2 sdl2 i2 b2})]
                            [(push gs (% gsp-proto
                                         'ex *unify*
                                         'dl+ (reverse dl1)
                                         'dl- (reverse dl2)))
                             (gs/next)]
                            [#f])]
                      [{{'kvar kv1 dl1} {'kvar kv2 dl2}}
                       (if3 [(equal? {adl1 sdl1 i1}
                                     {adl2 sdl2 i2})]
                            [(push gs (% gsp-proto
                                         'ex *unify*
                                         'dl+ (reverse (cons kv1 dl1))
                                         'dl- (reverse (cons kv2 dl2))))
                             (gs/next)]
                            [#f])]
                      [__ #f])])])))
      #+end_src

***** unify/arrow/arrow

      #+begin_src scheme
      (define (unify/arrow/arrow m d1 d2)
        (match {d1 d2}
          [{{'uni-arrow nl1 frc1 ajj1 sjj1}
            {'uni-arrow nl2 frc2 ajj2 sjj2}}
           (let* ([vrc1 (append frc1 (nl->vrc nl1))]
                  [vrc2 (append frc2 (nl->vrc nl2))]
                  [dl-ajj1 (call-with-output-to-new-ds
                            (lambda ()
                              (push rs (% rsp-proto
                                          'ex   compose
                                          'vrc  vrc1
                                          'jj   ajj1))
                              (rs/next)))]
                  [dl-ajj2 (call-with-output-to-new-ds
                            (lambda ()
                              (push rs (% rsp-proto
                                          'ex   compose
                                          'vrc  vrc2
                                          'jj   ajj2))
                              (rs/next)))])
             (if3 [(push gs (% gsp-proto
                               'ex *unify*
                               'dl+ (reverse dl-ajj1)
                               'dl- (reverse dl-ajj2)))
                   (gs/next)]
                  [(let* ([dl-sjj1 (call-with-output-to-new-ds
                                    (lambda ()
                                      (push rs (% rsp-proto
                                                  'ex   compose
                                                  'vrc  vrc1
                                                  'jj   sjj1))
                                      (rs/next)))]
                          [dl-sjj2 (call-with-output-to-new-ds
                                    (lambda ()
                                      (push rs (% rsp-proto
                                                  'ex   compose
                                                  'vrc  vrc2
                                                  'jj   sjj2))
                                      (rs/next)))])
                     (push gs (% gsp-proto
                                 'ex (cons `(unify ,m) (unify m))
                                 'dl+ (reverse dl-sjj1)
                                 'dl- (reverse dl-sjj2)))
                     (gs/next))]
                  [(debug0 'unify/arrow/arrow
                     ("unify fail~%")
                     ("ajj1 : ~a~%" ajj1)
                     ("ajj2 : ~a~%" ajj2)
                     ("dl-ajj1 : ~a~%" dl-ajj1)
                     ("dl-ajj2 : ~a~%" dl-ajj2))]))]))
      #+end_src

*** up-unify

***** up-unify

      #+begin_src scheme
      (define (up-unify m)
        (: method -> (-> bool))
        (lambda ()
          (let* ([gsp (pop gs)]
                 [c   (^ gsp 'c)]
                 [ex  (^ gsp 'ex)]
                 [dl1 (^ gsp 'dl+)]
                 [dl2 (^ gsp 'dl-)])
            (if3 [(>= c (length dl1))]
                 [#t]
                 [(push gs (% gsp 'c (+ 1 c)))
                  (if (up-unify/data/data m
                                          (list-ref dl1 c)
                                          (list-ref dl2 c))
                    (gs/next)
                    #f)]))))
      #+end_src

***** up-unify/data/data

      #+begin_src scheme
      ;; note that
      ;;   up-unify vs unify
      ;;   need not to be passed to nested structure
      ;;   thus we can simply call unify in up-unify

      (define (up-unify/data/data m d1 d2)
        (: data data -> bool)
        ;; var -walk-> fresh-var
        (let ([d1 (bs/walk d1)]
              [d2 (bs/walk d2)])
          (match {d1 d2}
            ;; ignore the sub-data
            ;;   for it is used by top-level type-check

            [{{'uni-bind uv d} __}
             (unify/data/data m (d2t d) d2)]
            [{__ {'uni-bind uv d}}
             (and (unify/data/data m (d2t d1) d)
                  (unify/data/data m d1 uv))]

            [{__ __} (unify/data/data m (d2t d1) d2)])))
      #+end_src

*** unifier

    #+begin_src scheme
    (define *unify* (cons '(unify 'unify) (unify 'unify)))
    (define *cover* (cons '(unify 'cover) (unify 'cover)))
    (define *up-unify* (cons '(up-unify 'unify) (up-unify 'unify)))
    (define *up-cover* (cons '(up-unify 'cover) (up-unify 'cover)))
    #+end_src

*** try-trunk

    #+begin_src scheme
    ;; although we can handle multi-return-value
    ;;   but one trunk only return one value
    ;;   a multi-return-value function will return many trunks

    (define (update-trunky! k0 k)
      (vector-set! k0 0 k))

    (define (try-trunk t)
      (: trunk -> (or #f data))
      (match t
        [{'trunk adl sdl k i}
         (match (vector-ref k 0)
           [{'done dl} (list-ref dl i)]
           [{'kvar kv dl}
            (match (bs/deep kv)
              [{'uni-lambda a al}
               ;; not check for type-arrow here
               (update-trunky! k {'todo al dl})
               (try-trunk t)]
              [__ #f])]
           [{'todo b dl}
            (let* ([ds0 ds]
                   [bs0 bs]
                   [gs0 gs]
                   [result
                    (let ()
                      (push-list ds dl)
                      (compose/try-body b))])
              (match result
                [{sjj vrc}
                 (list-ref (update-trunky! k (call-with-output-to-new-ds
                                              (lambda ()
                                                (push rs (% rsp-proto
                                                            'ex   compose
                                                            'vrc  vrc
                                                            'jj   sjj))
                                                (rs/next))))
                           i)]
                [#f
                 (set! ds ds0)
                 (set! bs bs0)
                 (set! gs gs0)
                 #f]))])]))
    #+end_src

*** occur-check

***** occur-check/data

      #+begin_src scheme
      (define (occur-check/data uv d)
        (: fresh-uni-var data -> bool)
        (match (bs/deep d)
          [{'uni-var id level} (not (uni-var/eq? uv d))]
          [{'cons n dl}        (occur-check/data-list uv dl)]
          [{'uni-bind v d}     (occur-check/data-list uv {v d})]
          [{'trunk t k i}      (occur-check/trunk uv d)]
          [__                  #t]))
      #+end_src

***** occur-check/data-list

      #+begin_src scheme
      (define (occur-check/data-list uv dl)
        (: fresh-uni-var {data ...} -> bool)
        (match dl
          [{} #t]
          [(d . r)
           (if (occur-check/data uv d)
             (occur-check/data-list uv r)
             #f)]))
      #+end_src

***** occur-check/trunk

      #+begin_src scheme
      (define (occur-check/trunk uv t)
        (: fresh-uni-var trunk -> bool)
        (match t
          [{'trunk t k i}
           (match (vector-ref k 0)
             [{'todo b dl} (occur-check/data-list uv dl)]
             [{'kvar kv1 dl} (occur-check/data-list uv (cons kv1 dl))]
             [{'done dl}   (occur-check/data-list uv dl)])]))
      #+end_src

* top

*** def

***** note

      - definers use the interface of compiler
        compile-arrow for def
        compile-jo for run

***** runtime flag

      #+begin_src scheme
      (define print-define-flag #f)
      (define (print-define+) (set! print-define-flag #t))
      (define (print-define-) (set! print-define-flag #f))

      (define type-check-flag #f)
      (define (type-check+) (set! type-check-flag #t))
      (define (type-check-) (set! type-check-flag #f))
      #+end_src

***** def

      #+begin_src scheme
      (define-macro (def name body)
        `($def (quote ,name) (quote ,body)))

      (define ($def name body)
        (let ([key (car body)])
          ((find-key key) name body)))

      (define key-record '())

      (define (new-key key fun)
        (set! key-record
              (cons (cons key fun)
                    key-record)))

      (define (find-key key)
        (let ([found (assq key key-record)])
          (if found
            (cdr found)
            (debug0 'find-key
              ("can not find key : ~a~%" key)))))
      #+end_src

***** print-def

      #+begin_src scheme
      (define (print-def n meaning)
        (cat ("~%")
             ("<def>~%")
             ("  :name: ~a~%" n)
             ("  :meaning:~%~a~%" meaning)
             ("</def>~%")
             ("~%")))
      #+end_src

***** def-lambda

      #+begin_src scheme
      (define (def-lambda n body)
        (let* ([a (compile-uni-arrow (cadr body))]
               [al (map compile-uni-arrow (cddr body))]
               [meaning (list 'meaning-lambda a al)])
          (push ns (cons n meaning))
          (if type-check-flag (type-check a al))
          (if print-define-flag (print-def n meaning))))

      (new-key 'lambda def-lambda)
      #+end_src

***** def-type & def-data

      - no type checking on def-type and def-data

      #+begin_src scheme
      (define (def-type n body)
        (let* ([a (compile-uni-arrow (cadr body))]
               [pl (apply pair-list (cddr body))]
               [nl (map car pl)]
               [meaning (list 'meaning-type a n nl)])
          (push ns (cons n meaning ))
          (if print-define-flag (print-def n meaning))
          (for-each (lambda (p) (def-data n p)) pl)))

      (new-key 'type def-type)

      (define (def-data n0 p)
        (let* ([n (car p)]
               [a (compile-uni-arrow (cdr p))]
               [meaning (list 'meaning-data a n n0)])
          (push ns (cons n meaning))
          (if print-define-flag (print-def n meaning))))
      #+end_src

*** run

    #+begin_src scheme
    (define-macro (run . s)
      `($run (quote ,s)))

    (define ($run s)
      (for-each compose/jo (map compile-jo s))
      (print-ds))
    #+end_src

*** type-check

    #+begin_src scheme
    (define (type-check ta al)
      (: uni-arrow {uni-arrow ...} -> bool)
      (match ta
        [('uni-arrow . __)
         (for-each (lambda (a) (type-check/arrow ta a))
                   al)]
        [__ (debug0 'type-check
              ("type of function must be uni-arrow~%")
              ("type : ~a~%" ta))]))

    (define (type-check/arrow ta a)
      (: type-arrow arrow -> bool)
      (match {ta a}
        [{{'uni-arrow tnl tfrc tajj tsjj}
          {'uni-arrow nl frc ajj sjj}}
         (let* ([ds0 ds]
                [bs0 bs]
                [gs0 gs]
                [tvrc (append tfrc (nl->vrc tnl))]
                [vrc (append frc (nl->vrc nl))]
                [dl-tajj (call-with-output-to-new-ds
                          (lambda ()
                            (push rs (% rsp-proto
                                        'ex  compose
                                        'vrc tvrc
                                        'jj  tajj))
                            (rs/next)))]
                [dl-ajj (call-with-output-to-new-ds
                         (lambda ()
                           (push rs (% rsp-proto
                                       'ex  compose
                                       'vrc vrc
                                       'jj  ajj))
                           (rs/next)))])
           (if3 [(push gs (% gsp-proto
                             'ex     *up-unify*
                             'dl+    (reverse dl-ajj)
                             'dl-    (reverse dl-tajj)))
                 (gs/next)]
                [(let* ([dl-tsjj (call-with-output-to-new-ds
                                  (lambda ()
                                    (push rs (% rsp-proto
                                                'ex  compose
                                                'vrc tvrc
                                                'jj  tsjj))
                                    (rs/next)))]
                        [dl-sjj (call-with-output-to-new-ds
                                 (lambda ()
                                   (push rs (% rsp-proto
                                               'ex  compose
                                               'vrc vrc
                                               'jj  sjj))
                                   (rs/next)))])
                   (if3 [(push gs (% gsp-proto
                                     'ex     *up-cover*
                                     'dl+    (reverse dl-sjj)
                                     'dl-    (reverse dl-tsjj)))
                         (gs/next)]
                        [(set! ds ds0)
                         (set! bs bs0)
                         (set! gs gs0)
                         #t]
                        [(debug0 'type-check/arrow
                           ("cover fail~%")
                           ("tsjj : ~a~%" tsjj)
                           ("dl-tsjj : ~a~%" dl-tsjj)
                           ("sjj : ~a~%" sjj)
                           ("dl-sjj : ~a~%" dl-sjj))]))]
                [(debug0 'type-check/arrow
                   ("unify fail~%")
                   ("tajj : ~a~%" tajj)
                   ("dl-tajj : ~a~%" dl-tajj)
                   ("ajj : ~a~%" ajj)
                   ("ajj : ~a~%" dl-ajj))]))]))
    #+end_src

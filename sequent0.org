#+PROPERTY: tangle sequent0.scm
#+title: sequent0

* todo

  - no define-jojo
    for we need a mini prototype language

  - new compiler with new syntax
    we can simply view [] as () for now

  - new compose/var cut/var

  - add a new field (which have two new lists) to arrow
    and use the rs to handle scope

* note

*** terminology

    | element | list of elements |
    |---------+------------------|
    | jo      | jojo             |
    | data    | data-list        |
    | arrow   | body             |

*** dispatching

    | jo      | data    | double data |
    |---------+---------+-------------|
    | compose | bs/deep | cover       |
    | cut     |         | unify       |

*** data & jo

    #+begin_src scheme :tangle no
    (type data
      uni-var            id   level
      cons               name {data ...}
      arrow              local jojo jojo
      lambda             arrow body
      bind               data sub-data
      trunk              type (vector trunky) index)

    (type local          occur-list bind-list)

    (type trunky
      todo               body {data ...}
      done               {data ...})

    (type jojo           {jo ...})
    (type body           {arrow ...})

    (type id             (vector (name . counter) ls))
    ;; vector thus unique
    ;; ls (level binding-list) in id for commit

    (type jo
      var                name
      call               name
      arrow              ~
      lambda             ~
      apply
      ex-bind            jo   jojo)
    #+end_src

*** meaning

    #+begin_src scheme :tangle no
    (type meaning
      meaning-type-cons  type name {name ...}
      meaning-data-cons  type name name
      meaning-jojo       type jojo
      meaning-function   type body)
    #+end_src

*** stack

    #+begin_src scheme :tangle no
    (type ns {(name . meaning) ...})

    (type ds {data ...})

    (type bs {(id . ls) ...})
    (type ls {(level . data) ...})

    (type rs {{counter explainer ender jojo} ...})
    (type gs {{counter explainer ender {data-list data-list}} ...})
    #+end_src

* stack

  #+begin_src scheme
  (define ns '())
  (define ds '())
  (define bs '())
  (define rs '())
  (define gs '())

  (define-macro (push s v) `(set! ,s (cons ,v ,s)))
  (define-macro (put s l)
    `(set! ,s (append ,l ,s)))

  (define (tos s) (car s))
  (define-macro (pop s)
    (let ([v (gensym "pop/v")])
      `(let ([,v (car ,s)])
         (set! ,s (cdr ,s))
         ,v)))
  (define-macro (fetch s n)
    (let ([v (gensym "fetch/v")])
      `(let ([,v (take ,s ,n)])
         (set! ,s (drop ,s ,n))
         ,v)))
  #+end_src

* compile

*** help

    #+begin_src scheme
    (define (head->name head)
      (car head))

    (define (head->type head)
      (cdr (cdr head)))
    #+end_src

*** compile-jo

    #+begin_src scheme
    (define (compile-jo jo)
      (define (var? v)
        (and (symbol? v)
             (equal? ":" (substring (symbol->string v) 0 1))))
      (define (call? v)
        (and (symbol? v)
             (not (eq? ":" (substring (symbol->string v) 0 1)))))
      (define (apply? v)
        (eq? v 'apply))
      (define (arrow? v)
        (and (list? v)
             (member '-> v)))
      (define (lambda? v)
        (and (list? v)
             (eq? (car v) 'lambda)))
      (define (ex-bind? v)
        (and (list? v) (pair? v)
             (member ': v)))
      (cond [(var? jo)                (list 'var jo)]
            [(call? jo)               (list 'call jo)]
            [(apply? jo)              (list 'apply)]
            [(arrow? jo)              (compile-arrow jo)]
            [(lambda? jo)             (compile-lambda jo)]
            [(ex-bind? jo)            (compile-ex-bind jo)]))
    #+end_src

*** compile-ex-bind

    #+begin_src scheme
    (define (compile-ex-bind jo)
      (list 'ex-bind
            (compile-jo (car (right-of ': jo)))
            (compile-jojo (left-of ': jo))))
    #+end_src

*** compile-jojo

    #+begin_src scheme
    (define (compile-jojo jojo)
      (map compile-jo jojo))
    #+end_src

*** compile-arrow

    #+begin_src scheme
    (define (compile-arrow arrow)
      (list 'arrow
            (compile-jojo (left-of '-> arrow))
            (compile-jojo (right-of '-> arrow))))
    #+end_src

*** compile-type

    #+begin_src scheme
    (define (compile-type type)
      (define (arrow? s)
        (and (eq? (length s) 1)
             (list? (car s))
             (member '-> (car s))))
      (cond [(arrow? type)
             (compile-arrow (car type))]
            [else
             (orz 'compile-type
               ("type must be an arrow : ~a~%" type))]))
    #+end_src

*** compile-body

    #+begin_src scheme
    (define (compile-body body)
      (map compile-arrow body))
    #+end_src

*** compile-lambda

    #+begin_src scheme
    (define (compile-lambda lambda)
      (list 'lambda
            (compile-type (car (cdr lambda)))
            (compile-body (cdr (cdr lambda)))))
    #+end_src

* define

*** print-define+ & print-define-

    #+begin_src scheme
    (define print-define-flag #f)
    (define (print-define+) (set! print-define-flag #t))
    (define (print-define-) (set! print-define-flag #f))
    #+end_src

*** type-check+ & type-check-

    #+begin_src scheme
    (define type-check-flag #f)
    (define (type-check+) (set! type-check-flag #t))
    (define (type-check-) (set! type-check-flag #f))
    #+end_src

*** def

    #+begin_src scheme
    (define-macro (def head . tail)
      `($def (quote ,head) (quote ,tail)))

    (define ($def head tail)
      (define name (head->name head))
      (define meaning
        (list 'meaning-function
              (compile-type (head->type head))
              (compile-body tail)))
      (push ns (cons name meaning))
      (if type-check-flag
        (match meaning
          [{'meaning-function pt pb}
           (let ([t pt]
                 [b pb])
             (type-check/function t b))]))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<def>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</def>\n")
          (display "\n"))))
    #+end_src

*** >< define-type

    #+begin_src scheme
    (define-macro (define-type head . tail)
      `($define-type (quote ,head) (quote ,tail)))

    (define ($define-type head tail)
      (define name (head->name head))
      (define data-name-list (map car tail))
      (define meaning
        (list 'meaning-type-cons
              (compile-type (head->type head))
              name
              data-name-list))
      (push ns (cons name meaning))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<define-type>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</define-type>\n")
          (display "\n")))
      (map (lambda (h)
             ($define-data h name))
        tail)
      (void))

    (define ($define-data head type-name)
      (define name (head->name head))
      (define meaning
        (list 'meaning-data-cons
              (compile-type (head->type head))
              name
              type-name))
      (push ns (cons name meaning))
      (if print-define-flag
        (let ()
          (display "\n")
          (display "<define-data>\n")
          (display ":name: ") (display name) (display "\n")
          (display ":meaning:\n")
          (display meaning) (display "\n")
          (display "</define-data>\n")
          (display "\n"))))
    #+end_src

* ><><><

*** id/new

    #+begin_src scheme
    (define id/counter 0)

    (define (id/new n ls)
      (set! id/counter (+ 1 id/counter))
      (vector (cons n id/counter) ls))
    #+end_src

* bs

*** bs/commit & id/commit

    #+begin_src scheme
    (define (bs/commit)
      (define (recur bs0)
        (cond [(equal? '(commit-point) (car bs0))
               (set! bs (cdr bs0))]
              [else
               (let ([id (car (car bs0))]
                     [ls (cdr (car bs0))])
                 (id/commit id ls)
                 (recur (cdr bs0)))]))
      (recur bs))

    (define (id/commit id ls)
      (: id ls -> id [with effect on id])
      (let ()
        (vector-set! id 1 (append ls (vector-ref id 1)))
        id))
    #+end_src

*** bs/extend & bs/extend-up

    #+begin_src scheme
    (define (bs/extend v d)
      (: var data -> !)
      (match v
        [{'var id level}
         (let ([found/ls (assq id bs)])
           (if found/ls
             (set! bs (substitute `(,id . ((,level . ,d) . ,(cdr found/ls)))
                                  (lambda (pair) (eq? (car pair) id))
                                  bs))
             (push bs `(,id . ((,level . ,d))))))]))

    (define (bs/extend-up v d)
      (: var data -> !)
      (match v
        [{'var id level}
         (let ([level (+ 1 level)]
               [found/ls (assq id bs)])
           (if found/ls
             (set! bs (substitute `(,id . ((,level . ,d) . ,(cdr found/ls)))
                                  (lambda (pair) (eq? (car pair) id))
                                  bs))
             (push bs `(,id . ((,level . ,d))))))]))

    ;; in compose/var & cut/var
    ;;   extend bs whenever meet a new var
    ;;   this helps commit

    ;; not using ><><><
    (define (bs/extend-new v d)
      (: var data -> !)
      (match v
        [{'var id level}
         (push bs `(,id . ((,level . ,d))))]))

    ;; (define (bs/extend-new v d)
    ;;   (: var data -> !)
    ;;   (match v
    ;;     [{'var id level}
    ;;      (let ([found/ls (assq id bs)])
    ;;        (if found/ls
    ;;          (void)
    ;;          (push bs `(,id . ()))))]))
    #+end_src

*** bs/find

    #+begin_src scheme
    (define (id->ls id)
      (vector-ref id 1))

    (define (bs/find v)
      (: var -> (or data #f))
      (match v
        [{'var id level}
         (let* ([found/commit (assq level (id->ls id))])
           (if found/commit
             (cdr found/commit)
             (let* ([found/ls (assq id bs)]
                    [found/bind
                     (if found/ls
                       (assq level (cdr found/ls))
                       #f)])
               (if found/bind
                 (cdr found/bind)
                 #f))))]))
    #+end_src

*** bs/walk

    #+begin_src scheme
    (define (bs/walk d)
      (: data -> data)
      (match d
        [{'var id level}
         (let ([found (bs/find d)])
           (if found
             (bs/walk found)
             d))]
        [__ d]))
    #+end_src

*** bs/deep

    #+begin_src scheme
    (define (bs/deep d)
      (: data -> data)
      (let ([d (bs/walk d)])
        (match d
          ;; a var is fresh after bs/walk
          [{'cons n dl}             {'cons n (bs/deep-list dl)}]
          [{'bind d sd}             {'bind (bs/deep d) (bs/deep sd)}]
          [{'trunk t k i}           {'trunk t (bs/deep-trunky k) i}]
          [__                    d])))

    (define (bs/deep-list dl)
      (map (lambda (x) (bs/deep x)) dl))

    (define (bs/deep-trunky k)
      (vector-set!
        k 0
        (match (vector-ref k 0)
          [{'todo b dl} {'todo b (bs/deep-list dl)}]
          [{'done dl}   {'done (bs/deep-list dl)}])))
    #+end_src

*** bs/find-up

    #+begin_src scheme
    (define (bs/find-up v)
      (: var -> (or data #f))
      (match v
        [{'var id level}
         (let* ([level (+ 1 level)]
                [found/commit (assq level (id->ls id))])
           (if found/commit
             (cdr found/commit)
             (let* ([found/ls (assq id bs)]
                    [found/bind
                     (if found/ls
                       (assq level (cdr found/ls))
                       #f)])
               (if found/bind
                 (cdr found/bind)
                 #f))))]))
    #+end_src

*** var/fresh?

    #+begin_src scheme
    (define (var/fresh? v)
      (: var -> bool)
      (equal? (bs/walk v)
              v))
    #+end_src

*** var/eq?

    #+begin_src scheme
    (define (var/eq? v1 v2)
      (match {v1 v2}
        [{{'var id1 level1} {'var id2 level2}}
         (and (eq? id1 id2)
              (eq? level1 level2))]))
    #+end_src

* occur-check

*** occur-check/data

    #+begin_src scheme
    (define (occur-check/data v d)
      (: fresh-var data -> bool)
      (match (bs/deep d)
        [{'var id level} (not (var/eq? v d))]
        [{'cons n dl}    (occur-check/data-list v dl)]
        [{'bind d sd}    (occur-check/data-list v {d sd})]
        [{'trunk t k i}  (occur-check/trunk v d)]
        [__              #t]))
    #+end_src

*** occur-check/data-list

    #+begin_src scheme
    (define (occur-check/data-list v dl)
      (: fresh-var {data ...} -> bool)
      (match dl
        [{} #t]
        [(d . r)
         (if (occur-check/data v d)
           (occur-check/data-list v r)
           #f)]))
    #+end_src

*** occur-check/trunk

    #+begin_src scheme
    (define (occur-check/trunk v t)
      (: fresh-var trunk -> bool)
      (match t
        [{'trunk t k i}
         (match (vector-ref k 0)
           [{'todo b dl} (occur-check/data-list dl)]
           [{'done dl}   (occur-check/data-list dl)])]))
    #+end_src

* gs

*** note goal-stack

    - binding-stack is to record solution of equations in goal-stack

*** gs/exit

    #+begin_src scheme
    (define (gs/exit) (void))
    #+end_src

*** gs/next

    #+begin_src scheme
    (define (gs/next)
      (: -> bool)
      (match (tos gs)
        [{c ex end {dl1 dl2}}
         (ex)]))
    #+end_src

* trunk

*** try-trunk

    #+begin_src scheme
    (define (try-trunk t)
      (: trunk -> (or #f data))
      (match t
        [{'trunk t k i}
         (match (vector-ref k 0)
           [{'done dl} (list-ref dl i)]
           [{'todo b dl}
            (put ds dl)
            (compose/function t b)
            (let ([result (pop ds)])
              (cond [(equal? result t) #f]
                    [else result]))])]))
    #+end_src

* cover

*** note

    - cover is the poset structure of term-lattice (subsumption-lattice)

    - only recur into data
      but not jo

*** cover

    #+begin_src scheme
    (define (cover)
      (: -> bool)
      (match (pop gs)
        [{c ex end {dl1 dl2}}
         (cond [(>= c (length dl1))
                (end)
                #t]
               [else
                (let ([d1 (list-ref dl1 c)]
                      [d2 (list-ref dl2 c)])
                  (push gs {(+ 1 c) ex end {dl1 dl2}})
                  (if (cover/data/data d1 d2)
                    (gs/next)
                    #f))])]))
    #+end_src

*** cover/data/data

    #+begin_src scheme
    (define (cover/data/data d1 d2)
      (: data data -> bool)
      ;; var -walk-> fresh-var
      (let ([d1 (bs/walk d1)]
            [d2 (bs/walk d2)])
        (match {d1 d2}
          ;; ignore the sub-data
          ;;   for it is used by top-level type-check
          [{{'bind d v} __} (cover/data/data d d2)]
          [{__ {'bind d v}} (cover/data/data d1 d)]
          ;; var is the hero
          ;; this should pass occur-check
          [{{'var id1 level1} {'var id2 level2}}
           (cond [(var/eq? d1 d2) #t] ;; no self-cover
                 [else (cover/var/data d1 d2)])]
          [{{'var id level} __} (cover/var/data d1 d2)]
          [{__ {'var id level}} #f] ;; the only difference from unify/data/data
          ;; cons push gs
          [{{'cons n1 dl1} {'cons n2 dl2}}
           (cond [(eq? n1 n2)
                  (push gs {0 cover gs/exit {dl1 dl2}})
                  (gs/next)]
                 [else #f])]
          ;; trunk is the tricky part
          ;;   semantic equal is used
          [{{'trunk t1 k1 i1} {'trunk t2 k2 i2}} (cover/trunk/trunk d1 d2)]
          [{{'trunk t k i} __} (cover/trunk/data d1 d2)]
          [{__ {'trunk t k i}} (cover/data/trunk d1 d2)]
          ;; others use syntax equal
          [{__ __} (equal? d1 d2)])))

    ;; ;; the equal? of scheme can handle circle
    ;; (let ([p1 (cons 1 1)]
    ;;       [p2 (cons 1 1)])
    ;;   (set-cdr! p1 p1)
    ;;   (set-cdr! p2 p2)
    ;;   (list p1 p2 (equal? p1 p2)))
    ;; ;; => (#0=(1 . #0#) #1=(1 . #1#) #t)
    #+end_src

*** cover/var/data

    #+begin_src scheme
    (define (cover/var/data v d)
      (: fresh-var data -> bool)
      ;; no consistent-check
      ;;   because we do not have infer
      (if (occur-check/data v d)
        (bs/extend v d)
        #f))
    #+end_src

*** cover/trunk/data

    #+begin_src scheme
    (define (cover/trunk/data t d)
      (let ([result (try-trunk t)])
        (if result
          (cover/data/data result d)
          #f)))
    #+end_src

*** cover/data/trunk

    #+begin_src scheme
    (define (cover/data/trunk d t)
      (let ([result (try-trunk t)])
        (if result
          (cover/data/data d result)
          #f)))
    #+end_src

*** cover/trunk/trunk

    #+begin_src scheme
    (define (cover/trunk/trunk t1 t2)
      (let ([result1 (try-trunk t1)]
            [result2 (try-trunk t2)])
        (cond [result1 (cover/data/trunk result1 t2)]
              [result2 (cover/trunk/data t1 result2)]
              [else
               ;; when both fail to try-trunk
               ;;   still have chance to syntax equal
               (match {t1 t2}
                 [{{'trunk t1 k1 i1} {'trunk t2 k2 i2}}
                  (match {(vector-ref k1 0) (vector-ref k2 0)}
                    [{{'todo b1 dl1} {'todo b2 dl2}}
                     (cond [(equal? {t1 i1 b1} {t2 i2 b2})
                            (push gs {0 cover gs/exit {dl1 dl2}})
                            (gs/next)]
                           [else #f])])])])))
    #+end_src

* unify

*** note

    - almost the same code as cover

    - this is the meet (greatest lower bound) operation of term-lattice

    - first order syntactic unification

    - for unify/trunk
      first syntactic unification is tried
      if it fail
      semantic unification is used

    - except for unify/trunk/data
      semantic unification (unification modulo theory) is tried
      (try trunk -> redex)
      (computation can occur in type-check)

    - no substitutional equality
      (no second order semantic unification)
      (but can use proved '=' to get explicit substitutional equality)

*** unify

    #+begin_src scheme
    (define (unify)
      (: -> bool)
      (match (pop gs)
        [{c ex end {dl1 dl2}}
         (cond [(>= c (length dl1))
                (end)
                #t]
               [else
                (let ([d1 (list-ref dl1 c)]
                      [d2 (list-ref dl2 c)])
                  (push gs {(+ 1 c) ex end {dl1 dl2}})
                  (if (unify/data/data d1 d2)
                    (gs/next)
                    #f))])]))
    #+end_src

*** unify/data/data

    #+begin_src scheme
    (define (unify/data/data d1 d2)
      (: data data -> bool)
      ;; var -walk-> fresh-var
      (let ([d1 (bs/walk d1)]
            [d2 (bs/walk d2)])
        (match {d1 d2}
          ;; ignore the sub-data
          ;;   for it is used by top-level type-check
          [{{'bind d v} __} (unify/data/data d d2)]
          [{__ {'bind d v}} (unify/data/data d1 d)]
          ;; var is the hero
          ;; this should pass occur-check
          [{{'var id1 level1} {'var id2 level2}}
           (cond [(var/eq? d1 d2) #t] ;; no self-unify
                 [else (unify/var/data d1 d2)])]
          [{{'var id level} __} (unify/var/data d1 d2)]
          [{__ {'var id level}} (unify/var/data d2 d1)]
          ;; cons push gs
          [{{'cons n1 dl1} {'cons n2 dl2}}
           (cond [(eq? n1 n2)
                  (push gs {0 unify gs/exit {dl1 dl2}})
                  (gs/next)]
                 [else #f])]
          ;; trunk is the tricky part
          ;;   semantic equal is used
          [{{'trunk t1 k1 i1} {'trunk t2 k2 i2}} (unify/trunk/trunk d1 d2)]
          [{{'trunk t k i} __} (unify/trunk/data d1 d2)]
          [{__ {'trunk t k i}} (unify/data/trunk d1 d2)]
          ;; others use syntax equal
          [{__ __} (equal? d1 d2)])))

    ;; ;; the equal? of scheme can handle circle
    ;; (let ([p1 (cons 1 1)]
    ;;       [p2 (cons 1 1)])
    ;;   (set-cdr! p1 p1)
    ;;   (set-cdr! p2 p2)
    ;;   (list p1 p2 (equal? p1 p2)))
    ;; ;; => (#0=(1 . #0#) #1=(1 . #1#) #t)
    #+end_src

*** unify/var/data

    #+begin_src scheme
    (define (unify/var/data v d)
      (: fresh-var data -> bool)
      ;; no consistent-check
      ;;   because we do not have infer
      (if (occur-check/data v d)
        (bs/extend v d)
        #f))
    #+end_src

*** unify/trunk/data

    #+begin_src scheme
    (define (unify/trunk/data t d)
      (let ([result (try-trunk t)])
        (if result
          (unify/data/data result d)
          #f)))
    #+end_src

*** unify/data/trunk

    #+begin_src scheme
    (define (unify/data/trunk d t)
      (let ([result (try-trunk t)])
        (if result
          (unify/data/data d result)
          #f)))
    #+end_src

*** unify/trunk/trunk

    #+begin_src scheme
    (define (unify/trunk/trunk t1 t2)
      (let ([result1 (try-trunk t1)]
            [result2 (try-trunk t2)])
        (cond [result1 (unify/data/trunk result1 t2)]
              [result2 (unify/trunk/data t1 result2)]
              [else
               ;; when both fail to try-trunk
               ;;   still have chance to syntax equal
               (match {t1 t2}
                 [{{'trunk t1 k1 i1} {'trunk t2 k2 i2}}
                  (match {(vector-ref k1 0) (vector-ref k2 0)}
                    [{{'todo b1 dl1} {'todo b2 dl2}}
                     (cond [(equal? {t1 i1 b1} {t2 i2 b2})
                            (push gs {0 unify gs/exit {dl1 dl2}})
                            (gs/next)]
                           [else #f])])])])))
    #+end_src

* rs

*** rs/exit

    #+begin_src scheme
    (define (rs/exit) (void))
    #+end_src

*** rs/next

    #+begin_src scheme
    (define (rs/next)
      (match (tos rs)
        [{c ex end jj}
         (ex)]))
    #+end_src

* compose

*** compose

    #+begin_src scheme
    (define (compose)
      (match (pop rs)
        [{c ex end jj}
         (cond [(>= c (length jj))
                (end)]
               [else
                (let ([j (list-ref jj c)])
                  (push rs {(+ 1 c) ex end jj})
                  (compose/jo j)
                  (rs/next))])]))
    #+end_src

*** compose/jo

    #+begin_src scheme
    (define (compose/jo j)
      (case (car j)
        ['var           (compose/var j)]
        ['call          (compose/call j)]
        ['apply         (compose/apply j)]
        ['ex-bind       (compose/ex-bind j)]
        [__             (push ds j)]))
    #+end_src

*** compose/jojo

    - ><><><
      maybe do not need this

    #+begin_src scheme
    (define (compose/jojo jj) (for-each compose/jo jj))
    #+end_src

*** compose/var

    #+begin_src scheme
    (define (compose/var j)
      ;; (if (var/fresh? j)
      ;;   (bs/extend-new j))
      (let ([d (bs/deep j)])
        (push ds d)))
    #+end_src

*** type/input-number & type/output-number

    - it is assumed that jojo as type do not eat data-stack

    #+begin_src scheme
    (define (type/input-number t)
      (match t
        [{'arrow ajj sjj}
         (length (call-with-output-to-new-ds
                  (lambda () (compose/jojo ajj))))]))

    (define (type/output-number t)
      (match t
        [{'arrow ajj sjj}
         (length (call-with-output-to-new-ds
                  (lambda () (compose/jojo sjj))))]))
    #+end_src

*** note compose/call

    - [for the first covering arrow]
      #+begin_src scheme :tangle no
      <data-on-the-stack>
      <point>
      (push rs {compose exit <antecedent>})
      <ds/gather>
      (push gs {cover commit <gathered>})
      succ -> commit (<loop>)
      fail -> undo
      (push rs {compose exit <succedent>})
      all fail -> form trunk
      #+end_src

*** compose/call & compose/function

    #+begin_src scheme
    (define (compose/call j)
      (match j
        [{'call n}
         (let ([found (assq n ns)])
           (if (not found)
             (orz 'compose/call ("unknow name : ~a~%" n))
             (match (cdr found)
               [{'meaning-type-cons pt n nl}
                (let ([len (type/input-number pt)])
                  (push ds {'cons n (fetch ds len)}))]
               [{'meaning-data-cons pt n n0}
                (let ([len (type/input-number pt)])
                  (push ds {'cons n (fetch ds len)}))]
               [{'meaning-jojo pt pjj}
                (push rs {0 compose rs/next pjj})]
               [{'meaning-function pt pb}
                (compose/function pt pb)])))]))

    (define (compose/function t b)
      ;; note that
      ;;   when create-trunk-list
      ;;   it needs to know the type to get input-number & output-number
      (let ([sjj (compose/try-body b)])
        (if sjj
          (push rs {0 compose rs/next sjj})
          (let ([dl (fetch ds (type/input-number t))])
            (put ds (create-trunk-list t b dl))))))

    (define (compose/try-body b)
      (: body -> (or #f sjj))
      ;; return #f on fail
      ;; return sjj on success with commit
      (match b
        [{} #f]
        [({'arrow ajj sjj} . r)
         (let* ([ds0 ds]
                [bs0 bs]
                [gs0 gs])
           (let* ([dl1 (call-with-output-to-new-ds
                        (lambda ()
                          (push rs {0 compose rs/exit ajj})
                          (rs/next)))]
                  [dl2 (fetch ds (length dl1))])
             (push bs '(commit-point))
             (push gs {0 cover bs/commit {dl1 dl2}})
             (if (gs/next)
               sjj
               (let ()
                 (set! ds ds0)
                 (set! bs bs0)
                 (set! gs gs0)
                 (compose/try-body r)))))]))

    (define (create-trunk-list t b dl)
      (let ([k (vector {'todo b dl})])
        (reverse
         (map (lambda (i) {'trunk t k i})
           (genlist (type/output-number pt))))))
    #+end_src

*** compose/apply

    #+begin_src scheme
    (define (compose/apply j)
      (match (bs/walk (pop ds))
        [{'lambda t b}
         (compose/function t b)]
        [__ (orz 'compose/apply
              ("can not handle jo : ~a~%" j))]))
    #+end_src

*** compose/ex-bind

    - here use {'ex-bind j vl}
      instead of {'ex-bind j jj}
      because {'bind data non-var} can only be generated by cut

    #+begin_src scheme
    (define (compose/ex-bind j)
      (match j
        [{'ex-bind j vl}
         (let* ([dl (call-with-output-to-new-ds
                     (lambda ()
                       (compose/jo j)))]
                [d (car dl)])
           (if (not (eq? (length dl) 1))
             (orz 'compose/ex-bind
               ("jo should return one data~%")
               ("but this jo does not : ~a~%" j))
             (for-each (lambda (v)
                         (bs/extend-up v d)
                         (push ds {'bind d v}))
                       vl)))]))
    #+end_src

* cut

*** cut

    #+begin_src scheme
    (define (cut)
      (match (pop rs)
        [{c ex end jj}
         (cond [(>= c (length jj))
                (end)]
               [else
                (let ([j (list-ref jj c)])
                  (push rs {(+ 1 c) ex end jj})
                  (cut/jo j)
                  (rs/next))])]))
    #+end_src

*** cut/jo

    #+begin_src scheme
    (define (cut/jo j)
      (case (car j)
        ['var           (cut/var j)]
        ['call          (cut/call j)]
        ['apply         (cut/apply j)]
        ['arrow         (cut/arrow j)]
        ['lambda        (cut/lambda j)]
        ['ex-bind       (cut/ex-bind j)]))
    #+end_src

*** cut/var

    #+begin_src scheme
    (define (cut/var j)
      ;; (if (var/fresh? j)
      ;;   (bs/extend-new j))
      (let ([d (bs/deep j)])
        (let ([found-d (bs/find-up j)])
          (if found-d
            (push ds found-d)
            (match j
              [{'var id level}
               (push ds {'var id (+ 1 level)})])))))
    #+end_src

*** cut/call & cut/type

    #+begin_src scheme
    (define (cut/call j)
      (match j
        [{'call n}
         (let ([found (assq n ns)])
           (if (not found)
             (orz 'cut/call ("unknow name : ~a~%" n))
             (match (cdr found)
               [{'meaning-type-cons pt n nl}
                (cut/type pt)]
               [{'meaning-data-cons pt n n0}
                (cut/type pt)]
               [{'meaning-jojo pt pjj}
                (cut/type pt)]
               [{'meaning-function pt pb}
                (cut/type pt)])))]))

    (define (cut/type a)
      (: arrow -> !)
      (match a
        [{'arrow ajj sjj}
         (let* ([dl1 (call-with-output-to-new-ds
                      (lambda ()
                        (push rs {0 compose rs/exit ajj})
                        (rs/next)))]
                [dl2 (fetch ds (length dl1))])
           (push bs '(commit-point))
           (push gs {0 unify bs/commit {dl1 dl2}})
           (if (gs/next)
             (compose/jojo sjj)
             (orz 'cut/type
               ("fail on unify~%"))))]))
    #+end_src

*** cut/apply

    #+begin_src scheme
    (define (cut/apply j)
      (match (bs/walk (pop ds))
        [{'arrow ajj sjj}
         (cut/type {'arrow ajj sjj})]
        [__ (orz 'cut/apply
              ("can not handle jo : ~a~%" j))]))
    #+end_src

*** cut/arrow

    #+begin_src scheme
    (define (cut/arrow j)
      (orz 'cut/arrow
        ("can not handle arrow as jo that is not in type~%")
        ("jo : ~a~%" j)))
    #+end_src

*** cut/lambda

    - lambda -> arrow

    #+begin_src scheme
    (define (cut/lambda j)
      (match j
        [{'lambda {'arrow ajj sjj} b}
         (push ds {'arrow ajj sjj})]
        [__
         (orz 'cut/lambda
           ("can not handle jo : ~a~%" j)
           ("for it is meaning less to write a lambda without local-vars~%"))]))
    #+end_src

*** cut/ex-bind

    #+begin_src scheme
    (define (cut/ex-bind j)
      (orz 'cut/ex-bind
        ("can not handle ex-bind as jo that is not in type~%")
        ("jo : ~a~%" j)))
    #+end_src

* ds

*** call-with-output-to-new-ds

    #+begin_src scheme
    (define (call-with-output-to-new-ds f)
      (: function -> new-ds)
      (let ([ds-backup ds])
        (set! ds '())
        (f)
        (let ([new-ds ds])
          (set! ds ds-backup)
          new-ds)))
    #+end_src

* top-level

*** app

    #+begin_src scheme
    (define-macro (app s)
      `($app (quote ,s)))

    (define ($app s)
      (compose/jojo (compile/jojo s)))
    #+end_src

*** type-check/jojo

    #+begin_src scheme
    (define (type-check/jojo t jj)
      (: type jojo -> bool)
      (match t
        [{'arrow tajj tsjj}
         (let* ([dl1 (call-with-output-to-new-ds
                      (lambda ()
                        (push rs {0 compose rs/exit tajj})
                        (rs/next)
                        (push rs {0 cut rs/exit jj})
                        (rs/next)))]
                [dl2 (call-with-output-to-new-ds
                      (lambda ()
                        (push rs {0 compose rs/exit tsjj})
                        (rs/next)))])
           (push gs {0 unify gs/exit {dl1 dl2}})
           (cond [(gs/exit)
                  #t]
                 [else (orz 'type-check/jojo
                         ("cover fail~%"))]))]))
    #+end_src

*** note type-check/function without bind-unify

    - body [for all arrow]
      #+begin_src scheme :tangle no
      (push rs {compose <type-antecedent>})
      <point>
      (push rs {cut <antecedent>})
      <ds/gather>
      (push gs {unify <gathered>})

      (push rs {compose <type-succedent>})
      <point>
      (push rs {cut <succedent>})
      <ds/gather>
      (push gs {cover <gathered>})
      <undo-when-success>
      #+end_src

*** note type-check/function

    - body [for all arrow]
      #+begin_src scheme :tangle no
      (push rs {compose <type-antecedent>})
      <point>
      (push rs {compose <antecedent>})
      <ds/gather>
      (push gs {bind-unify <gathered>})

      <undo>
      (push rs {cut <antecedent>})
      <ds/gather>
      (push gs {unify <gathered>})

      (push rs {compose <type-succedent>})
      <point>
      (push rs {cut <succedent>})
      <ds/gather>
      (push gs {cover <gathered>})
      <undo-when-success>
      #+end_src

*** ><><>< type-check/function

    - ><><>< in lack of bind-unify

    #+begin_src scheme
    (define (type-check/function t b)
      (: type body -> bool)
      (match t
        [{'arrow tajj tsjj}
         (for-each (lambda (a) (type-check/arrow t a))
                   b)]
        [__ (orz 'type-check/function
              ("type of function must be arrow~%")
              ("type : ~a~%" t))]))

    (define (type-check/arrow ta a)
      (: type-arrow arrow -> bool)
      (match {ta a}
        [{{'arrow tajj tsjj} {'arrow ajj sjj}}
         (let* ([dl1 (call-with-output-to-new-ds
                      (lambda ()
                        (push rs {0 compose rs/exit tajj})
                        (rs/next)))]
                [dl2 (call-with-output-to-new-ds
                      (lambda ()
                        (push rs {0 cut rs/exit ajj})
                        (rs/next)))])
           (push gs {0 unify gs/exit {dl1 dl2}})
           (cond [(gs/next)
                  (let* ([dl3 (call-with-output-to-new-ds
                               (lambda ()
                                 (push rs {0 compose rs/exit tsjj})
                                 (rs/next)))]
                         [dl4 (call-with-output-to-new-ds
                               (lambda ()
                                 (push rs {0 cut rs/exit sjj})
                                 (rs/next)))])
                    (push gs {0 cover gs/exit {dl3 dl4}})
                    (cond [(gs/exit)
                           #t]
                          [else (orz 'type-check/arrow
                                  ("cover fail~%"))]))]
                 [else (orz 'type-check/arrow
                         ("unify fail~%"))]))]))
    #+end_src
